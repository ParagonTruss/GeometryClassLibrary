<?xml version="1.0"?>
<doc>
    <assembly>
        <name>UnitClassLibrary</name>
    </assembly>
    <members>
        <member name="T:UnitClassLibrary.Angle">
            <summary>
            Class used for storing Angles that may need to be accessed in a different measurement system
            Accepts anything as input
            
            For an explanation of why this class is immutable: http://codebetter.com/patricksmacchia/2008/01/13/immutable-types-understand-them-and-use-them/
            
            <example>
            radians into degrees then returned as string
            
            double radians = 10.5;
            Angle a = new Angle(AngleType.Radian, radians);
            
            a.Degrees.ToString()         //for decimal degrees
            a.ToString(AngleType.Degree) //for formatted string
            </example>
            
            </summary>
        </member>
        <member name="M:UnitClassLibrary.AngularDistance.#ctor(UnitClassLibrary.AngularDistanceEqualityStrategy)">
            <summary> Zero Constructor </summary>
        </member>
        <member name="M:UnitClassLibrary.AngularDistance.#ctor(UnitClassLibrary.AngleType,System.Double,UnitClassLibrary.AngularDistanceEqualityStrategy)">
            <summary> Accepts standard types for input. </summary>
        </member>
        <member name="M:UnitClassLibrary.AngularDistance.#ctor(UnitClassLibrary.AngularDistance)">
            <summary> Copy constructor (new unit with same fields as the passed) </summary>
        </member>
        <member name="M:UnitClassLibrary.AngularDistance.ConvertAngularDistance(UnitClassLibrary.AngleType,System.Double,UnitClassLibrary.AngleType)">
            <summary>Converts one unit of AngularDistance to another</summary>
            <param name="typeConvertingTo">input unit type</param>
            <param name="passedValue"></param>
            <param name="typeConvertingFrom">desired output unit type</param>
            <returns>passedValue in desired units</returns>
        </member>
        <member name="M:UnitClassLibrary.AngularDistance.EqualsWithinDeviationConstant(UnitClassLibrary.AngularDistance,UnitClassLibrary.AngularDistance)">
            <summary>
            value comparison, checks whether the two are equal within a passed accepted equality deviation
            </summary>
        </member>
        <member name="M:UnitClassLibrary.AngularDistance.EqualsWithinDeviationPercentage(UnitClassLibrary.AngularDistance,System.Double)">
            <summary>
            value comparison, checks whether the two are equal within a passed accepted equality percentage
            </summary>
        </member>
        <member name="M:UnitClassLibrary.AngularDistance.EqualsWithinAngularDistanceEqualityStrategy(UnitClassLibrary.AngularDistance,UnitClassLibrary.AngularDistanceEqualityStrategy)">
            <summary>
            value comparison, checks whether the two are equal within a passed accepted equality percentage
            </summary>
        </member>
        <member name="M:UnitClassLibrary.AngularDistance.CompareTo(UnitClassLibrary.AngularDistance)">
            <summary> This implements the IComparable (AngularDistance) interface and allows AngularDistances to be sorted and such </summary>
        </member>
        <member name="M:UnitClassLibrary.AngularDistance.CompareTo(System.Object)">
            <summary> This implements the IComparable (AngularDistance) interface and allows AngularDistances to be sorted and such </summary>
        </member>
        <member name="M:UnitClassLibrary.AngularDistance.op_ExclusiveOr(UnitClassLibrary.AngularDistance,System.Double)">
            <summary>
            The "raise to power" operator
            </summary>
            <param name="d1"></param>
            <param name="power"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.AngularDistance.op_Addition(UnitClassLibrary.AngularDistance,UnitClassLibrary.AngularDistance)">
            <summary>
            returns a new AngularDistance with the sum of the two passed AngularDistances
            </summary>
            <param name="d1"></param>
            <param name="d2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.AngularDistance.op_Subtraction(UnitClassLibrary.AngularDistance,UnitClassLibrary.AngularDistance)">
            <summary>
            returns a new AngularDistance with the difference of the two passed AngularDistances
            </summary>
            <param name="d1"></param>
            <param name="d2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.AngularDistance.op_Division(UnitClassLibrary.AngularDistance,UnitClassLibrary.AngularDistance)">
            <summary>
            ratio of between AngularDistances
            </summary>
            <param name="d1"></param>
            <param name="d2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.AngularDistance.op_Multiply(UnitClassLibrary.AngularDistance,System.Double)">
            <summary>
            scalar multiplication
            </summary>
            <param name="d1"></param>
            <param name="multiplier"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.AngularDistance.op_Division(UnitClassLibrary.AngularDistance,System.Double)">
            <summary>
            scalar division
            </summary>
            <param name="d1"></param>
            <param name="divisor"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.AngularDistance.op_Equality(UnitClassLibrary.AngularDistance,UnitClassLibrary.AngularDistance)">
            <summary>
            Not a perfect equality operator, is only accurate up to Constants.AcceptedEqualityDeviationConstant 
            </summary>
        </member>
        <member name="M:UnitClassLibrary.AngularDistance.op_Inequality(UnitClassLibrary.AngularDistance,UnitClassLibrary.AngularDistance)">
            <summary>
            Not a perfect inequality operator, is only accurate up to Constants.AcceptedEqualityDeviationConstant 
            </summary>
        </member>
        <member name="M:UnitClassLibrary.AngularDistance.op_GreaterThan(UnitClassLibrary.AngularDistance,UnitClassLibrary.AngularDistance)">
            <summary>
            greater than
            </summary>
            <param name="d1"></param>
            <param name="d2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.AngularDistance.op_LessThan(UnitClassLibrary.AngularDistance,UnitClassLibrary.AngularDistance)">
            <summary>
            less than
            </summary>
            <param name="d1"></param>
            <param name="d2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.AngularDistance.op_LessThanOrEqual(UnitClassLibrary.AngularDistance,UnitClassLibrary.AngularDistance)">
            <summary>
            Less than or equal to
            </summary>
            <param name="d1"></param>
            <param name="d2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.AngularDistance.op_GreaterThanOrEqual(UnitClassLibrary.AngularDistance,UnitClassLibrary.AngularDistance)">
            <summary>
            Greater than or equal to
            </summary>
            <param name="d1"></param>
            <param name="d2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.AngularDistance.GetHashCode">
            <summary>
            This override determines how this object is inserted into hashtables.
            </summary>
            <returns>same hashcode as any double would</returns>
        </member>
        <member name="M:UnitClassLibrary.AngularDistance.ToString">
            <summary>
            The value and unit in terms of what the object was created with. 
            If you want it in a different unit use ToString(AngularDistanceType)
            </summary>
        </member>
        <member name="M:UnitClassLibrary.AngularDistance.Equals(System.Object)">
            <summary>
            calls the Dimension only Equals method
            </summary>
        </member>
        <member name="M:UnitClassLibrary.AngularDistance.Equals(UnitClassLibrary.AngularDistance)">
            <summary>
            Compares using the function specified by strategy
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.AngularDistance.ToString(UnitClassLibrary.AngleType)">
            <summary>prints the value and unit type converted to</summary>
            <param name="AngleType"></param>
        </member>
        <member name="M:UnitClassLibrary.AngularDistance.Negate">
            <summary>Creates a new object that is the negative of this</summary><returns>new object with value equivalent to result</returns>
        </member>
        <member name="M:UnitClassLibrary.AngularDistance.AbsoluteValue">
            <summary>Creates a new object that is the absolute value of this</summary><returns>new object with value equivalent to result</returns>
        </member>
        <member name="M:UnitClassLibrary.AngularDistance.RaiseToPower(System.Double)">
            <summary> multiplies itself a given number of times</summary><returns>new object with value equivalent to result</returns>
        </member>
        <member name="M:UnitClassLibrary.AngularDistance.MakeAngularDistanceWithRadians(System.Double)">
            <summary>Generator method that constructs AngularDistance with assumption that the passed value is in Radians</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.AngularDistance.MakeAngularDistanceWithDegrees(System.Double)">
            <summary>Generator method that constructs AngularDistance with assumption that the passed value is in Degrees</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Angle.#ctor">
            <summary>
            Empty Constructor
            </summary>
        </member>
        <member name="M:UnitClassLibrary.Angle.#ctor(UnitClassLibrary.AngleType,System.Double)">
            <summary>
            Create an angle object from an angle value.
            </summary>
            <param name="AngleType">angle unit type</param>
            <param name="passedValue">angle value</param>
        </member>
        <member name="M:UnitClassLibrary.Angle.#ctor(UnitClassLibrary.Angle)">
            <summary>
            Copy Constructor
            </summary>
            <param name="passedAngle">angle to copy</param>
        </member>
        <member name="M:UnitClassLibrary.Angle.op_Addition(UnitClassLibrary.Angle,UnitClassLibrary.Angle)">
            <summary>
            adds the two angles together
            </summary>
            <param name="a1">first angle</param>
            <param name="a2">second angle</param>
            <returns>the sum of the two angles</returns>
        </member>
        <member name="M:UnitClassLibrary.Angle.op_Subtraction(UnitClassLibrary.Angle,UnitClassLibrary.Angle)">
            <summary>
            subtracts one angle from the other
            </summary>
            <param name="a1">the angle to be subtracted from</param>
            <param name="a2">the angle to subtract</param>
            <returns>the result of the first angle minus the second</returns>
        </member>
        <member name="M:UnitClassLibrary.Angle.GetHashCode">
            <summary>
            This override determines how this object is inserted into hashtables.
            </summary>
            <returns>same hashcode as any double would</returns>
        </member>
        <member name="M:UnitClassLibrary.Angle.ToString">
            <summary>
            The value and unit in terms of what the object was created with. 
            If you want it in a different unit use ToString(AngleType)
            </summary>
            <returns>Should never return anything</returns>
        </member>
        <member name="M:UnitClassLibrary.Angle.Reverse">
            <summary>
            Finds the angle that points 180 degrees from this one
            </summary>
            <returns>Angle 180 degrees from this one</returns>
        </member>
        <member name="M:UnitClassLibrary.Angle.Negate">
            <summary>
            Returns an Angle object that is negated
            </summary>
            <returns>Angle that is same but from opposite colckwise direction </returns>
        </member>
        <member name="T:UnitClassLibrary.AngleType">
            <summary> Enum for specifying the type of unit a AngularDistance is.</summary>
        </member>
        <member name="T:UnitClassLibrary.AngularDistanceEqualityStrategy">
            <summary>
            delegate that defines the form of 
            </summary>
            <param name="AngularDistance1"></param>
            <param name="AngularDistance2"></param>
            <returns></returns>
        </member>
        <member name="T:UnitClassLibrary.DeviationDefaults">
            <summary>
            Default deviations allowed when comparing AngularDistance objects.
            </summary>
            <summary>
            Deviations that are acceptable when doing equality checks
            </summary>
            <summary>
            Default deviations allowed when comparing Distance objects.
            </summary>
        </member>
        <member name="P:UnitClassLibrary.DeviationDefaults.AcceptedEqualityDeviationAngularDistance">
            <summary>
            When comparing two AngularDistances and deviation is allowed to be within a specific constant. This is that default constant
            </summary>
        </member>
        <member name="P:UnitClassLibrary.DeviationDefaults.AcceptedEqualityDeviationAngularDistancePercentage">
            <summary>
            When comparing two AngularDistances and deviation is allowed to be within a percentage of the first AngularDistance. This is that percentage
            </summary>
        </member>
        <member name="P:UnitClassLibrary.DeviationDefaults.AcceptedEqualityDeviationDistance">
            <summary>
            When comparing two distances and deviation is allowed to be within a specific constant. This is that default constant
            </summary>
        </member>
        <member name="P:UnitClassLibrary.DeviationDefaults.AcceptedEqualityDeviationDistancePercentage">
            <summary>
            When comparing two distances and deviation is allowed to be within a percentage of the first Distance. This is that percentage
            </summary>
        </member>
        <member name="T:UnitClassLibrary.AngularDistanceEqualityStrategyImplementations">
            <summary>
            functions that can be used for a AngularDistance object's equals function
            </summary>
        </member>
        <member name="M:UnitClassLibrary.AngularDistanceEqualityStrategyImplementations.DefaultPercentageEquality(UnitClassLibrary.AngularDistance,UnitClassLibrary.AngularDistance)">
            <summary>
            AngularDistances are equal if they differ by less than a percentage of the first AngularDistance
            </summary>
            <param name="AngularDistance1">first AngularDistance being compared</param>
            <param name="AngularDistance2">second AngularDistance being compared</param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.AngularDistanceEqualityStrategyImplementations.DefaultConstantEquality(UnitClassLibrary.AngularDistance,UnitClassLibrary.AngularDistance)">
            <summary>
            AngularDistances are equal if there values are within the passed deviation constant. If they are not within the constant
            </summary>
            <param name="AngularDistance1">first AngularDistance being compared</param>
            <param name="AngularDistance2">second AngularDistance being compared</param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Capacitance.#ctor(UnitClassLibrary.CapacitanceEqualityStrategy)">
            <summary> Zero Constructor </summary>
        </member>
        <member name="M:UnitClassLibrary.Capacitance.#ctor(UnitClassLibrary.CapacitanceType,System.Double,UnitClassLibrary.CapacitanceEqualityStrategy)">
            <summary> Accepts standard types for input. </summary>
        </member>
        <member name="M:UnitClassLibrary.Capacitance.#ctor(UnitClassLibrary.Capacitance)">
            <summary> Copy constructor (new unit with same fields as the passed) </summary>
        </member>
        <member name="M:UnitClassLibrary.Capacitance.ConvertCapacitance(UnitClassLibrary.CapacitanceType,System.Double,UnitClassLibrary.CapacitanceType)">
            <summary>Converts one unit of Capacitance to another</summary>
            <param name="typeConvertingTo">input unit type</param>
            <param name="passedValue"></param>
            <param name="typeConvertingFrom">desired output unit type</param>
            <returns>passedValue in desired units</returns>
        </member>
        <member name="M:UnitClassLibrary.Capacitance.EqualsWithinDeviationConstant(UnitClassLibrary.Capacitance,UnitClassLibrary.Capacitance)">
            <summary> value comparison, checks whether the two are equal within a passed accepted equality deviation </summary>
        </member>
        <member name="M:UnitClassLibrary.Capacitance.EqualsWithinDeviationPercentage(UnitClassLibrary.Capacitance,UnitClassLibrary.Capacitance)">
            <summary> value comparison, checks whether the two are equal within a passed accepted equality percentage </summary>
        </member>
        <member name="M:UnitClassLibrary.Capacitance.EqualsWithinDistanceEqualityStrategy(UnitClassLibrary.Capacitance,UnitClassLibrary.CapacitanceEqualityStrategy)">
            <summary> value comparison, checks whether the two are equal within a passed accepted equality percentage </summary>
        </member>
        <member name="M:UnitClassLibrary.Capacitance.CompareTo(UnitClassLibrary.Capacitance)">
            <summary> This implements the IComparable (Capacitance) interface and allows Capacitances to be sorted and such </summary>
        </member>
        <member name="M:UnitClassLibrary.Capacitance.CompareTo(System.Object)">
            <summary> This implements the IComparable (Capacitance) interface and allows Capacitances to be sorted and such </summary>
        </member>
        <member name="M:UnitClassLibrary.Capacitance.op_ExclusiveOr(UnitClassLibrary.Capacitance,System.Double)">
            <summary>Raise to power operator</summary>
            <param name="o1"></param>
            <param name="power"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Capacitance.op_Addition(UnitClassLibrary.Capacitance,UnitClassLibrary.Capacitance)">
            <summary>Returns new unit with sum of two passed units</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Capacitance.op_Subtraction(UnitClassLibrary.Capacitance,UnitClassLibrary.Capacitance)">
            <summary>Returns new unit with difference of two passed units</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Capacitance.op_Division(UnitClassLibrary.Capacitance,UnitClassLibrary.Capacitance)">
            <summary>ratio between differences</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Capacitance.op_Multiply(UnitClassLibrary.Capacitance,System.Double)">
            <summary>scalar multiplication</summary>
            <param name="o1"></param>
            <param name="multiplier"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Capacitance.op_Multiply(System.Double,UnitClassLibrary.Capacitance)">
            <summary>scalar multiplication</summary>
            <param name="o1"></param>
            <param name="multiplier"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Capacitance.op_Division(UnitClassLibrary.Capacitance,System.Double)">
            <summary>scalar division</summary>
            <param name="o1"></param>
            <param name="divisor"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Capacitance.op_Inequality(UnitClassLibrary.Capacitance,UnitClassLibrary.Capacitance)">
            <summary>Not a perfect inequality operator, is only accurate up to Constants.AcceptedEqualityDeviationConstant </summary>
        </member>
        <member name="M:UnitClassLibrary.Capacitance.op_Equality(UnitClassLibrary.Capacitance,UnitClassLibrary.Capacitance)">
            <summary>Not a perfect equality operator, is only accurate up to Constants.AcceptedEqualityDeviationConstant </summary>
        </member>
        <member name="M:UnitClassLibrary.Capacitance.op_GreaterThan(UnitClassLibrary.Capacitance,UnitClassLibrary.Capacitance)">
            <summary>greater than</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Capacitance.op_LessThan(UnitClassLibrary.Capacitance,UnitClassLibrary.Capacitance)">
            <summary>less than</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Capacitance.op_LessThanOrEqual(UnitClassLibrary.Capacitance,UnitClassLibrary.Capacitance)">
            <summary>less than or equal to</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Capacitance.op_GreaterThanOrEqual(UnitClassLibrary.Capacitance,UnitClassLibrary.Capacitance)">
            <summary>greater than or equal to</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Capacitance.GetHashCode">
            <summary>This override determines how this object is inserted into hashtables.</summary>
            <returns>same hashcode as any double would</returns>
        </member>
        <member name="M:UnitClassLibrary.Capacitance.ToString">
            <summary>The value and unit in terms of what the object was created with. </summary>
            <returns>Should never return anything</returns>
        </member>
        <member name="M:UnitClassLibrary.Capacitance.Equals(System.Object)">
            <summary>calls the Dimension only Equals method</summary>
        </member>
        <member name="M:UnitClassLibrary.Capacitance.Equals(UnitClassLibrary.Capacitance)">
            <summary>Compares using the function specified by strategy</summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Capacitance.ToString(UnitClassLibrary.CapacitanceType)">
            <summary>prints the value and unit type converted to</summary>
            <param name="capacitanceType"></param>
        </member>
        <member name="M:UnitClassLibrary.Capacitance.Negate">
            <summary>Creates a new object that is the negative of this</summary><returns>new object with value equivalent to result</returns>
        </member>
        <member name="M:UnitClassLibrary.Capacitance.AbsoluteValue">
            <summary>Creates a new object that is the absolute value of this</summary><returns>new object with value equivalent to result</returns>
        </member>
        <member name="M:UnitClassLibrary.Capacitance.RaiseToPower(System.Double)">
            <summary> multiplies itself a given number of times</summary><returns>new object with value equivalent to result</returns>
        </member>
        <member name="M:UnitClassLibrary.Capacitance.MakeCapacitanceWithPicofarads(System.Double)">
            <summary>Generator method that constructs Capacitance with assumption that the passed value is in Picofarads</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Capacitance.MakeCapacitanceWithNanofarads(System.Double)">
            <summary>Generator method that constructs Capacitance with assumption that the passed value is in Nanofarads</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Capacitance.MakeCapacitanceWithMicrofarads(System.Double)">
            <summary>Generator method that constructs Capacitance with assumption that the passed value is in Microfarads</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Capacitance.MakeCapacitanceWithMillifarads(System.Double)">
            <summary>Generator method that constructs Capacitance with assumption that the passed value is in Millifarads</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Capacitance.MakeCapacitanceWithFarads(System.Double)">
            <summary>Generator method that constructs Capacitance with assumption that the passed value is in Farads</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Capacitance.MakeCapacitanceWithAbfarads(System.Double)">
            <summary>Generator method that constructs Capacitance with assumption that the passed value is in Abfarads</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Capacitance.MakeCapacitanceWithStatfarads(System.Double)">
            <summary>Generator method that constructs Capacitance with assumption that the passed value is in Statfarads</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="T:UnitClassLibrary.CapacitanceType">
            <summary> Enum for specifying the type of unit a Capacitance is.</summary>
        </member>
        <member name="T:UnitClassLibrary.CapacitanceEqualityStrategy">
            <summary>delegate that defines the form of</summary>
            <param name="capacitance1"></param>
            <param name="capacitance2"></param>
            <returns></returns>
        </member>
        <member name="T:UnitClassLibrary.CapacitanceDeviationDefaults">
            <summary> Default deviations allowed when comparing Capacitance objects </summary>
        </member>
        <member name="P:UnitClassLibrary.CapacitanceDeviationDefaults.AcceptedEqualityDeviationDistance">
            <summary> When comparing two capacitance and deviation is allowed to be within a specific constant. This is that default constant </summary>
        </member>
        <member name="P:UnitClassLibrary.CapacitanceDeviationDefaults.CapacitanceAcceptedEqualityDeviationDistancePercentage">
            <summary> When comparing two capacitance and deviation is allowed to be within a percentage of the firstCapacitance. This is that percentage </summary>
        </member>
        <member name="T:UnitClassLibrary.CapacitanceEqualityStrategyImplementations">
            <summary> functions that can be used for a capacitance object's equals functions </summary>
        </member>
        <member name="M:UnitClassLibrary.CapacitanceEqualityStrategyImplementations.DefaultPercentageEquality(UnitClassLibrary.Capacitance,UnitClassLibrary.Capacitance)">
            <summary> Capacitances are equal if they differ by less than a percentage of the first Capacitance </summary>
            <param name="capacitance1">first capacitance being compared</param>
            <param name="capacitance2">second capacitance being compared</param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.CapacitanceEqualityStrategyImplementations.DefaultConstantEquality(UnitClassLibrary.Capacitance,UnitClassLibrary.Capacitance)">
            <summary> Capacitances are equal if there values are within the passed deviation constant. If they are not within the constant </summary>
            <param name="capacitance1">first capacitance being compared</param>
            <param name="capacitance2">second capacitance being compared</param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.#ctor(UnitClassLibrary.DataTransferRateEqualityStrategy)">
            <summary> Zero Constructor </summary>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.#ctor(UnitClassLibrary.Data,UnitClassLibrary.Time,UnitClassLibrary.DataTransferRateEqualityStrategy)">
            <summary> constructor that creates moment based on the passed units </summary>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.#ctor(UnitClassLibrary.DataTransferRateType,System.Double)">
            <summary> Copy constructor (new unit with same fields as the passed) </summary>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.EqualsWithinDeviationConstant(UnitClassLibrary.DataTransferRate,UnitClassLibrary.DataTransferRate)">
            <summary> value comparison, checks whether the two are equal within a passed accepted equality deviation </summary>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.EqualsWithinDeviationPercentage(UnitClassLibrary.DataTransferRate,UnitClassLibrary.DataTransferRate)">
            <summary> value comparison, checks whether the two are equal within a passed accepted equality percentage </summary>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.EqualsWithinDistanceEqualityStrategy(UnitClassLibrary.DataTransferRate,UnitClassLibrary.DataTransferRateEqualityStrategy)">
            <summary> value comparison, checks whether the two are equal within a passed accepted equality percentage </summary>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.CompareTo(UnitClassLibrary.DataTransferRate)">
            <summary> This implements the IComparable (DataTransferRate) interface and allows DataTransferRates to be sorted and such </summary>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.CompareTo(System.Object)">
            <summary> This implements the IComparable (DataTransferRate) interface and allows DataTransferRates to be sorted and such </summary>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.op_ExclusiveOr(UnitClassLibrary.DataTransferRate,System.Double)">
            <summary>Raise to power operator</summary>
            <param name="o1"></param>
            <param name="power"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.op_Addition(UnitClassLibrary.DataTransferRate,UnitClassLibrary.DataTransferRate)">
            <summary>Returns new unit with sum of two passed units</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.op_Subtraction(UnitClassLibrary.DataTransferRate,UnitClassLibrary.DataTransferRate)">
            <summary>Returns new unit with difference of two passed units</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.op_Division(UnitClassLibrary.DataTransferRate,UnitClassLibrary.DataTransferRate)">
            <summary>ratio between differences</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.op_Multiply(UnitClassLibrary.DataTransferRate,System.Double)">
            <summary>scalar multiplication</summary>
            <param name="o1"></param>
            <param name="multiplier"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.op_Multiply(System.Double,UnitClassLibrary.DataTransferRate)">
            <summary>scalar multiplication</summary>
            <param name="o1"></param>
            <param name="multiplier"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.op_Division(UnitClassLibrary.DataTransferRate,System.Double)">
            <summary>scalar division</summary>
            <param name="o1"></param>
            <param name="divisor"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.op_Inequality(UnitClassLibrary.DataTransferRate,UnitClassLibrary.DataTransferRate)">
            <summary>Not a perfect inequality operator, is only accurate up to Constants.AcceptedEqualityDeviationConstant </summary>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.op_Equality(UnitClassLibrary.DataTransferRate,UnitClassLibrary.DataTransferRate)">
            <summary>Not a perfect equality operator, is only accurate up to Constants.AcceptedEqualityDeviationConstant </summary>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.op_GreaterThan(UnitClassLibrary.DataTransferRate,UnitClassLibrary.DataTransferRate)">
            <summary>greater than</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.op_LessThan(UnitClassLibrary.DataTransferRate,UnitClassLibrary.DataTransferRate)">
            <summary>less than</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.op_LessThanOrEqual(UnitClassLibrary.DataTransferRate,UnitClassLibrary.DataTransferRate)">
            <summary>less than or equal to</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.op_GreaterThanOrEqual(UnitClassLibrary.DataTransferRate,UnitClassLibrary.DataTransferRate)">
            <summary>greater than or equal to</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.GetHashCode">
            <summary>This override determines how this object is inserted into hashtables.</summary>
            <returns>same hashcode as any double would</returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.ToString">
            <summary>The value and unit in terms of what the object was created with. </summary>
            <returns>Should never return anything</returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.Equals(System.Object)">
            <summary>calls the Dimension only Equals method</summary>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.Equals(UnitClassLibrary.DataTransferRate)">
            <summary>Compares using the function specified by strategy</summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.ToString(UnitClassLibrary.DataTransferRateType)">
            <summary>prints the value and unit type converted to</summary>
            <param name="datatransferrateType"></param>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.Negate">
            <summary>Creates a new object that is the negative of this</summary><returns>new object with value equivalent to result</returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.AbsoluteValue">
            <summary>Creates a new object that is the absolute value of this</summary><returns>new object with value equivalent to result</returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.RaiseToPower(System.Double)">
            <summary> multiplies itself a given number of times</summary><returns>new object with value equivalent to result</returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithBitsPerNanoseconds(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in BitsPerNanoseconds</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithBitsPerMicroseconds(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in BitsPerMicroseconds</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithBitsPerMilliseconds(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in BitsPerMilliseconds</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithBitsPerSeconds(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in BitsPerSeconds</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithBitsPerMinutes(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in BitsPerMinutes</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithBitsPerHours(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in BitsPerHours</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithBitsPerDays(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in BitsPerDays</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithBitsPerWeeks(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in BitsPerWeeks</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithBitsPerMonths(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in BitsPerMonths</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithBitsPerYears(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in BitsPerYears</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithBitsPerDecades(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in BitsPerDecades</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithBitsPerCenturies(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in BitsPerCenturies</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithBytesPerNanoseconds(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in BytesPerNanoseconds</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithBytesPerMicroseconds(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in BytesPerMicroseconds</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithBytesPerMilliseconds(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in BytesPerMilliseconds</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithBytesPerSeconds(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in BytesPerSeconds</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithBytesPerMinutes(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in BytesPerMinutes</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithBytesPerHours(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in BytesPerHours</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithBytesPerDays(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in BytesPerDays</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithBytesPerWeeks(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in BytesPerWeeks</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithBytesPerMonths(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in BytesPerMonths</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithBytesPerYears(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in BytesPerYears</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithBytesPerDecades(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in BytesPerDecades</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithBytesPerCenturies(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in BytesPerCenturies</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithKilobytesPerNanoseconds(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in KilobytesPerNanoseconds</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithKilobytesPerMicroseconds(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in KilobytesPerMicroseconds</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithKilobytesPerMilliseconds(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in KilobytesPerMilliseconds</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithKilobytesPerSeconds(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in KilobytesPerSeconds</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithKilobytesPerMinutes(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in KilobytesPerMinutes</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithKilobytesPerHours(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in KilobytesPerHours</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithKilobytesPerDays(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in KilobytesPerDays</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithKilobytesPerWeeks(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in KilobytesPerWeeks</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithKilobytesPerMonths(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in KilobytesPerMonths</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithKilobytesPerYears(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in KilobytesPerYears</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithKilobytesPerDecades(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in KilobytesPerDecades</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithKilobytesPerCenturies(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in KilobytesPerCenturies</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithMegabytesPerNanoseconds(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in MegabytesPerNanoseconds</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithMegabytesPerMicroseconds(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in MegabytesPerMicroseconds</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithMegabytesPerMilliseconds(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in MegabytesPerMilliseconds</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithMegabytesPerSeconds(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in MegabytesPerSeconds</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithMegabytesPerMinutes(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in MegabytesPerMinutes</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithMegabytesPerHours(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in MegabytesPerHours</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithMegabytesPerDays(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in MegabytesPerDays</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithMegabytesPerWeeks(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in MegabytesPerWeeks</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithMegabytesPerMonths(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in MegabytesPerMonths</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithMegabytesPerYears(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in MegabytesPerYears</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithMegabytesPerDecades(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in MegabytesPerDecades</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithMegabytesPerCenturies(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in MegabytesPerCenturies</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithGigabytesPerNanoseconds(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in GigabytesPerNanoseconds</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithGigabytesPerMicroseconds(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in GigabytesPerMicroseconds</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithGigabytesPerMilliseconds(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in GigabytesPerMilliseconds</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithGigabytesPerSeconds(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in GigabytesPerSeconds</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithGigabytesPerMinutes(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in GigabytesPerMinutes</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithGigabytesPerHours(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in GigabytesPerHours</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithGigabytesPerDays(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in GigabytesPerDays</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithGigabytesPerWeeks(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in GigabytesPerWeeks</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithGigabytesPerMonths(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in GigabytesPerMonths</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithGigabytesPerYears(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in GigabytesPerYears</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithGigabytesPerDecades(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in GigabytesPerDecades</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithGigabytesPerCenturies(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in GigabytesPerCenturies</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithTerabytesPerNanoseconds(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in TerabytesPerNanoseconds</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithTerabytesPerMicroseconds(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in TerabytesPerMicroseconds</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithTerabytesPerMilliseconds(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in TerabytesPerMilliseconds</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithTerabytesPerSeconds(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in TerabytesPerSeconds</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithTerabytesPerMinutes(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in TerabytesPerMinutes</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithTerabytesPerHours(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in TerabytesPerHours</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithTerabytesPerDays(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in TerabytesPerDays</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithTerabytesPerWeeks(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in TerabytesPerWeeks</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithTerabytesPerMonths(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in TerabytesPerMonths</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithTerabytesPerYears(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in TerabytesPerYears</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithTerabytesPerDecades(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in TerabytesPerDecades</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithTerabytesPerCenturies(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in TerabytesPerCenturies</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithPetabytesPerNanoseconds(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in PetabytesPerNanoseconds</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithPetabytesPerMicroseconds(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in PetabytesPerMicroseconds</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithPetabytesPerMilliseconds(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in PetabytesPerMilliseconds</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithPetabytesPerSeconds(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in PetabytesPerSeconds</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithPetabytesPerMinutes(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in PetabytesPerMinutes</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithPetabytesPerHours(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in PetabytesPerHours</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithPetabytesPerDays(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in PetabytesPerDays</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithPetabytesPerWeeks(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in PetabytesPerWeeks</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithPetabytesPerMonths(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in PetabytesPerMonths</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithPetabytesPerYears(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in PetabytesPerYears</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithPetabytesPerDecades(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in PetabytesPerDecades</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithPetabytesPerCenturies(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in PetabytesPerCenturies</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithExabytesPerNanoseconds(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in ExabytesPerNanoseconds</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithExabytesPerMicroseconds(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in ExabytesPerMicroseconds</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithExabytesPerMilliseconds(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in ExabytesPerMilliseconds</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithExabytesPerSeconds(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in ExabytesPerSeconds</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithExabytesPerMinutes(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in ExabytesPerMinutes</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithExabytesPerHours(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in ExabytesPerHours</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithExabytesPerDays(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in ExabytesPerDays</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithExabytesPerWeeks(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in ExabytesPerWeeks</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithExabytesPerMonths(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in ExabytesPerMonths</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithExabytesPerYears(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in ExabytesPerYears</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithExabytesPerDecades(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in ExabytesPerDecades</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithExabytesPerCenturies(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in ExabytesPerCenturies</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithZettabytesPerNanoseconds(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in ZettabytesPerNanoseconds</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithZettabytesPerMicroseconds(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in ZettabytesPerMicroseconds</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithZettabytesPerMilliseconds(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in ZettabytesPerMilliseconds</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithZettabytesPerSeconds(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in ZettabytesPerSeconds</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithZettabytesPerMinutes(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in ZettabytesPerMinutes</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithZettabytesPerHours(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in ZettabytesPerHours</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithZettabytesPerDays(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in ZettabytesPerDays</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithZettabytesPerWeeks(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in ZettabytesPerWeeks</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithZettabytesPerMonths(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in ZettabytesPerMonths</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithZettabytesPerYears(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in ZettabytesPerYears</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithZettabytesPerDecades(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in ZettabytesPerDecades</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithZettabytesPerCenturies(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in ZettabytesPerCenturies</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithYottabytesPerNanoseconds(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in YottabytesPerNanoseconds</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithYottabytesPerMicroseconds(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in YottabytesPerMicroseconds</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithYottabytesPerMilliseconds(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in YottabytesPerMilliseconds</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithYottabytesPerSeconds(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in YottabytesPerSeconds</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithYottabytesPerMinutes(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in YottabytesPerMinutes</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithYottabytesPerHours(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in YottabytesPerHours</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithYottabytesPerDays(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in YottabytesPerDays</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithYottabytesPerWeeks(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in YottabytesPerWeeks</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithYottabytesPerMonths(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in YottabytesPerMonths</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithYottabytesPerYears(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in YottabytesPerYears</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithYottabytesPerDecades(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in YottabytesPerDecades</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRate.MakeDataTransferRateWithYottabytesPerCenturies(System.Double)">
            <summary>Generator method that constructs DataTransferRate with assumption that the passed value is in YottabytesPerCenturies</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="T:UnitClassLibrary.DataTransferRateType">
            <summary> Enum for specifying the type of unit a DataTransferRate is.</summary>
        </member>
        <member name="T:UnitClassLibrary.DataTransferRateEqualityStrategy">
            <summary>delegate that defines the form of</summary>
            <param name="datatransferrate1"></param>
            <param name="datatransferrate2"></param>
            <returns></returns>
        </member>
        <member name="T:UnitClassLibrary.DataTransferRateDeviationDefaults">
            <summary> Default deviations allowed when comparing DataTransferRate objects </summary>
        </member>
        <member name="P:UnitClassLibrary.DataTransferRateDeviationDefaults.AcceptedEqualityDeviationDistance">
            <summary> When comparing two datatransferrate and deviation is allowed to be within a specific constant. This is that default constant </summary>
        </member>
        <member name="P:UnitClassLibrary.DataTransferRateDeviationDefaults.DataTransferRateAcceptedEqualityDeviationDistancePercentage">
            <summary> When comparing two datatransferrate and deviation is allowed to be within a percentage of the firstDataTransferRate. This is that percentage </summary>
        </member>
        <member name="T:UnitClassLibrary.DataTransferRateEqualityStrategyImplementations">
            <summary> functions that can be used for a datatransferrate object's equals functions </summary>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRateEqualityStrategyImplementations.DefaultPercentageEquality(UnitClassLibrary.DataTransferRate,UnitClassLibrary.DataTransferRate)">
            <summary> DataTransferRates are equal if they differ by less than a percentage of the first DataTransferRate </summary>
            <param name="datatransferrate1">first datatransferrate being compared</param>
            <param name="datatransferrate2">second datatransferrate being compared</param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataTransferRateEqualityStrategyImplementations.DefaultConstantEquality(UnitClassLibrary.DataTransferRate,UnitClassLibrary.DataTransferRate)">
            <summary> DataTransferRates are equal if there values are within the passed deviation constant. If they are not within the constant </summary>
            <param name="datatransferrate1">first datatransferrate being compared</param>
            <param name="datatransferrate2">second datatransferrate being compared</param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Data.#ctor(UnitClassLibrary.DataEqualityStrategy)">
            <summary> Zero Constructor </summary>
        </member>
        <member name="M:UnitClassLibrary.Data.#ctor(UnitClassLibrary.DataType,System.Double,UnitClassLibrary.DataEqualityStrategy)">
            <summary> Accepts standard types for input. </summary>
        </member>
        <member name="M:UnitClassLibrary.Data.#ctor(UnitClassLibrary.Data)">
            <summary> Copy constructor (new unit with same fields as the passed) </summary>
        </member>
        <member name="M:UnitClassLibrary.Data.ConvertData(UnitClassLibrary.DataType,System.Double,UnitClassLibrary.DataType)">
            <summary>Converts one unit of Data to another</summary>
            <param name="typeConvertingTo">input unit type</param>
            <param name="passedValue"></param>
            <param name="typeConvertingFrom">desired output unit type</param>
            <returns>passedValue in desired units</returns>
        </member>
        <member name="M:UnitClassLibrary.Data.EqualsWithinDeviationConstant(UnitClassLibrary.Data,UnitClassLibrary.Data)">
            <summary> value comparison, checks whether the two are equal within a passed accepted equality deviation </summary>
        </member>
        <member name="M:UnitClassLibrary.Data.EqualsWithinDeviationPercentage(UnitClassLibrary.Data,UnitClassLibrary.Data)">
            <summary> value comparison, checks whether the two are equal within a passed accepted equality percentage </summary>
        </member>
        <member name="M:UnitClassLibrary.Data.EqualsWithinDistanceEqualityStrategy(UnitClassLibrary.Data,UnitClassLibrary.DataEqualityStrategy)">
            <summary> value comparison, checks whether the two are equal within a passed accepted equality percentage </summary>
        </member>
        <member name="M:UnitClassLibrary.Data.CompareTo(UnitClassLibrary.Data)">
            <summary> This implements the IComparable (Data) interface and allows Datas to be sorted and such </summary>
        </member>
        <member name="M:UnitClassLibrary.Data.CompareTo(System.Object)">
            <summary> This implements the IComparable (Data) interface and allows Datas to be sorted and such </summary>
        </member>
        <member name="M:UnitClassLibrary.Data.op_ExclusiveOr(UnitClassLibrary.Data,System.Double)">
            <summary>Raise to power operator</summary>
            <param name="o1"></param>
            <param name="power"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Data.op_Addition(UnitClassLibrary.Data,UnitClassLibrary.Data)">
            <summary>Returns new unit with sum of two passed units</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Data.op_Subtraction(UnitClassLibrary.Data,UnitClassLibrary.Data)">
            <summary>Returns new unit with difference of two passed units</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Data.op_Division(UnitClassLibrary.Data,UnitClassLibrary.Data)">
            <summary>ratio between differences</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Data.op_Multiply(UnitClassLibrary.Data,System.Double)">
            <summary>scalar multiplication</summary>
            <param name="o1"></param>
            <param name="multiplier"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Data.op_Multiply(System.Double,UnitClassLibrary.Data)">
            <summary>scalar multiplication</summary>
            <param name="o1"></param>
            <param name="multiplier"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Data.op_Division(UnitClassLibrary.Data,System.Double)">
            <summary>scalar division</summary>
            <param name="o1"></param>
            <param name="divisor"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Data.op_Inequality(UnitClassLibrary.Data,UnitClassLibrary.Data)">
            <summary>Not a perfect inequality operator, is only accurate up to Constants.AcceptedEqualityDeviationConstant </summary>
        </member>
        <member name="M:UnitClassLibrary.Data.op_Equality(UnitClassLibrary.Data,UnitClassLibrary.Data)">
            <summary>Not a perfect equality operator, is only accurate up to Constants.AcceptedEqualityDeviationConstant </summary>
        </member>
        <member name="M:UnitClassLibrary.Data.op_GreaterThan(UnitClassLibrary.Data,UnitClassLibrary.Data)">
            <summary>greater than</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Data.op_LessThan(UnitClassLibrary.Data,UnitClassLibrary.Data)">
            <summary>less than</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Data.op_LessThanOrEqual(UnitClassLibrary.Data,UnitClassLibrary.Data)">
            <summary>less than or equal to</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Data.op_GreaterThanOrEqual(UnitClassLibrary.Data,UnitClassLibrary.Data)">
            <summary>greater than or equal to</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Data.GetHashCode">
            <summary>This override determines how this object is inserted into hashtables.</summary>
            <returns>same hashcode as any double would</returns>
        </member>
        <member name="M:UnitClassLibrary.Data.ToString">
            <summary>The value and unit in terms of what the object was created with. </summary>
            <returns>Should never return anything</returns>
        </member>
        <member name="M:UnitClassLibrary.Data.Equals(System.Object)">
            <summary>calls the Dimension only Equals method</summary>
        </member>
        <member name="M:UnitClassLibrary.Data.Equals(UnitClassLibrary.Data)">
            <summary>Compares using the function specified by strategy</summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Data.ToString(UnitClassLibrary.DataType)">
            <summary>prints the value and unit type converted to</summary>
            <param name="dataType"></param>
        </member>
        <member name="M:UnitClassLibrary.Data.Negate">
            <summary>Creates a new object that is the negative of this</summary><returns>new object with value equivalent to result</returns>
        </member>
        <member name="M:UnitClassLibrary.Data.AbsoluteValue">
            <summary>Creates a new object that is the absolute value of this</summary><returns>new object with value equivalent to result</returns>
        </member>
        <member name="M:UnitClassLibrary.Data.RaiseToPower(System.Double)">
            <summary> multiplies itself a given number of times</summary><returns>new object with value equivalent to result</returns>
        </member>
        <member name="M:UnitClassLibrary.Data.MakeDataWithBits(System.Double)">
            <summary>Generator method that constructs Data with assumption that the passed value is in Bits</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Data.MakeDataWithBytes(System.Double)">
            <summary>Generator method that constructs Data with assumption that the passed value is in Bytes</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Data.MakeDataWithKilobytes(System.Double)">
            <summary>Generator method that constructs Data with assumption that the passed value is in Kilobytes</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Data.MakeDataWithMegabytes(System.Double)">
            <summary>Generator method that constructs Data with assumption that the passed value is in Megabytes</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Data.MakeDataWithGigabytes(System.Double)">
            <summary>Generator method that constructs Data with assumption that the passed value is in Gigabytes</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Data.MakeDataWithTerabytes(System.Double)">
            <summary>Generator method that constructs Data with assumption that the passed value is in Terabytes</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Data.MakeDataWithPetabytes(System.Double)">
            <summary>Generator method that constructs Data with assumption that the passed value is in Petabytes</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Data.MakeDataWithExabytes(System.Double)">
            <summary>Generator method that constructs Data with assumption that the passed value is in Exabytes</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Data.MakeDataWithZettabytes(System.Double)">
            <summary>Generator method that constructs Data with assumption that the passed value is in Zettabytes</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Data.MakeDataWithYottabytes(System.Double)">
            <summary>Generator method that constructs Data with assumption that the passed value is in Yottabytes</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="T:UnitClassLibrary.DataType">
            <summary> Enum for specifying the type of unit a Data is.</summary>
        </member>
        <member name="T:UnitClassLibrary.DataEqualityStrategy">
            <summary>delegate that defines the form of</summary>
            <param name="data1"></param>
            <param name="data2"></param>
            <returns></returns>
        </member>
        <member name="T:UnitClassLibrary.DataDeviationDefaults">
            <summary> Default deviations allowed when comparing Data objects </summary>
        </member>
        <member name="P:UnitClassLibrary.DataDeviationDefaults.AcceptedEqualityDeviationDistance">
            <summary> When comparing two data and deviation is allowed to be within a specific constant. This is that default constant </summary>
        </member>
        <member name="P:UnitClassLibrary.DataDeviationDefaults.DataAcceptedEqualityDeviationDistancePercentage">
            <summary> When comparing two data and deviation is allowed to be within a percentage of the firstData. This is that percentage </summary>
        </member>
        <member name="T:UnitClassLibrary.DataEqualityStrategyImplementations">
            <summary> functions that can be used for a data object's equals functions </summary>
        </member>
        <member name="M:UnitClassLibrary.DataEqualityStrategyImplementations.DefaultPercentageEquality(UnitClassLibrary.Data,UnitClassLibrary.Data)">
            <summary> Datas are equal if they differ by less than a percentage of the first Data </summary>
            <param name="data1">first data being compared</param>
            <param name="data2">second data being compared</param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.DataEqualityStrategyImplementations.DefaultConstantEquality(UnitClassLibrary.Data,UnitClassLibrary.Data)">
            <summary> Datas are equal if there values are within the passed deviation constant. If they are not within the constant </summary>
            <param name="data1">first data being compared</param>
            <param name="data2">second data being compared</param>
            <returns></returns>
        </member>
        <member name="T:UnitClassLibrary.Distance">
            <summary>
            This provides common constants that users might want to have predefined
            
            <example>
            The user would have to do this:
            
            Distance inch = new Distance(DistanceType.Inch, 1);
            
            if ( userDistance == inch)
            {
                do stuff...
            }
            
            But instead, they can do:
            
            if ( userDistance == Distance.Inch)
            {
                do stuff...
            }
            </example>
            </summary>
            <summary>
            Class used for storing Distances that may need to be accessed in a different measurement system
            
            For an explanation of why this class is immutable: http://codebetter.com/patricksmacchia/2008/01/13/immutable-types-understand-them-and-use-them/
            
            <example>
            decimal inches into architectural notation
            
            double inches = 14.1875
            Distance dm = new Distance(DistanceTypes.Inch, inches);
            
            Print(dm.Architectural)
            
            ========Output==========
            1'2 3/16"
            
            </example>
            </summary>
        </member>
        <member name="M:UnitClassLibrary.Distance.ConvertDistance(UnitClassLibrary.DistanceType,System.Double,UnitClassLibrary.DistanceType)">
            <summary>
            Converts any Unit of distance into another
            </summary>
            <param name="typeConvertingTo">input unit type</param>
            <param name="passedValue"></param>
            <param name="typeConvertingFrom">desired output unit type</param>
            <returns>passedValue in desired units</returns>
        </member>
        <member name="M:UnitClassLibrary.Distance.ConvertArchitectualStringtoUnit(UnitClassLibrary.DistanceType,System.String)">
            <summary>
            Converts any possible type of Architectual String into internal units
            </summary>
            <param name="convertToType"></param>
            <param name="passedArchitecturalString"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Distance.ConvertToArchitecturalString(UnitClassLibrary.DistanceType,System.Double,System.Int32)">
            <summary>
            Returns a string formatted in a standard AutoCAD format
            </summary>
        </member>
        <member name="M:UnitClassLibrary.Distance.ConvertDistanceIntoArchitecturalString(UnitClassLibrary.Distance)">
            <summary>
            Converts any Distance into an architectural string representation
            </summary>
            <returns>converted Distance</returns>
        </member>
        <member name="M:UnitClassLibrary.Distance.EqualsWithinDeviationConstant(UnitClassLibrary.Distance,UnitClassLibrary.Distance)">
            <summary>
            value comparison, checks whether the two are equal within a passed accepted equality deviation
            </summary>
        </member>
        <member name="M:UnitClassLibrary.Distance.EqualsWithinDeviationPercentage(UnitClassLibrary.Distance,System.Double)">
            <summary>
            value comparison, checks whether the two are equal within a passed accepted equality percentage
            </summary>
        </member>
        <member name="M:UnitClassLibrary.Distance.EqualsWithinDistanceEqualityStrategy(UnitClassLibrary.Distance,UnitClassLibrary.DistanceEqualityStrategy)">
            <summary>
            value comparison, checks whether the two are equal within a passed accepted equality percentage
            </summary>
        </member>
        <member name="M:UnitClassLibrary.Distance.CompareTo(UnitClassLibrary.Distance)">
            <summary>
            This implements the IComparable (Distance) interface and allows Distances to be sorted and such
            </summary>
            <param name="other">Distance being compared to</param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Distance.CompareTo(System.Object)">
            <summary>
            This implements the IComparable (Distance) interface and allows Distances to be sorted and such
            </summary>
            <param name="obj">object being compared to</param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Distance.op_ExclusiveOr(UnitClassLibrary.Distance,System.Double)">
            <summary>
            The "raise to power" operator
            </summary>
            <param name="d1"></param>
            <param name="power"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Distance.op_Addition(UnitClassLibrary.Distance,UnitClassLibrary.Distance)">
            <summary>
            returns a new Distance with the sum of the two passed distances
            </summary>
            <param name="d1"></param>
            <param name="d2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Distance.op_Subtraction(UnitClassLibrary.Distance,UnitClassLibrary.Distance)">
            <summary>
            returns a new Distance with the difference of the two passed distances
            </summary>
            <param name="d1"></param>
            <param name="d2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Distance.op_Division(UnitClassLibrary.Distance,UnitClassLibrary.Distance)">
            <summary>
            ratio of between distances
            </summary>
            <param name="d1"></param>
            <param name="d2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Distance.op_Multiply(UnitClassLibrary.Distance,UnitClassLibrary.Distance)">
            <summary>
            multiplication returned as area
            </summary>
            <param name="d1"></param>
            <param name="d2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Distance.op_Multiply(UnitClassLibrary.Distance,System.Double)">
            <summary>
            scalar multiplication
            </summary>
            <param name="d1"></param>
            <param name="multiplier"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Distance.op_Division(UnitClassLibrary.Distance,System.Double)">
            <summary>
            scalar division
            </summary>
            <param name="d1"></param>
            <param name="divisor"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Distance.op_Equality(UnitClassLibrary.Distance,UnitClassLibrary.Distance)">
            <summary>
            Not a perfect equality operator, is only accurate up to Constants.AcceptedEqualityDeviationConstant 
            </summary>
        </member>
        <member name="M:UnitClassLibrary.Distance.op_Inequality(UnitClassLibrary.Distance,UnitClassLibrary.Distance)">
            <summary>
            Not a perfect inequality operator, is only accurate up to Constants.AcceptedEqualityDeviationConstant 
            </summary>
        </member>
        <member name="M:UnitClassLibrary.Distance.op_GreaterThan(UnitClassLibrary.Distance,UnitClassLibrary.Distance)">
            <summary>
            greater than
            </summary>
            <param name="d1"></param>
            <param name="d2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Distance.op_LessThan(UnitClassLibrary.Distance,UnitClassLibrary.Distance)">
            <summary>
            less than
            </summary>
            <param name="d1"></param>
            <param name="d2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Distance.op_LessThanOrEqual(UnitClassLibrary.Distance,UnitClassLibrary.Distance)">
            <summary>
            Less than or equal to
            </summary>
            <param name="d1"></param>
            <param name="d2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Distance.op_GreaterThanOrEqual(UnitClassLibrary.Distance,UnitClassLibrary.Distance)">
            <summary>
            Greater than or equal to
            </summary>
            <param name="d1"></param>
            <param name="d2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Distance.GetHashCode">
            <summary>
            This override determines how this object is inserted into hashtables.
            </summary>
            <returns>same hashcode as any double would</returns>
        </member>
        <member name="M:UnitClassLibrary.Distance.ToString">
            <summary>
            The value and unit in terms of what the object was created with. 
            If you want it in a different unit use ToString(DistanceType)
            </summary>
        </member>
        <member name="M:UnitClassLibrary.Distance.Equals(System.Object)">
            <summary>
            calls the Dimension only Equals method
            </summary>
        </member>
        <member name="M:UnitClassLibrary.Distance.Equals(UnitClassLibrary.Distance)">
            <summary>
            Compares using the function specified by strategy
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Distance.ToString(UnitClassLibrary.DistanceType)">
            <summary>
            prints the value and unit type converted to
            </summary>
            <param name="distanceType"></param>
        </member>
        <member name="M:UnitClassLibrary.Distance.Negate">
            <summary>
            Creates a new Distance that is the negative of this
            </summary>
            <returns>new Distance object with value equivalent to result</returns>
        </member>
        <member name="M:UnitClassLibrary.Distance.AbsoluteValue">
            <summary>
            Creates a new Distance that is the absolute value of this
            </summary>
            <returns>new Distance object with value equivalent to result</returns>
        </member>
        <member name="M:UnitClassLibrary.Distance.RaiseToPower(System.Double)">
            <summary>
            multiplies itself a given number of times
            </summary>
            <param name="power">number of times to multiply by</param>
            <returns>new Distance object with value equivalent to result</returns>
        </member>
        <member name="F:UnitClassLibrary.Distance._intrinsicValue">
            <summary>
            The actual value of the stored unit. the 5 in "5 kilometers"
            </summary> 
        </member>
        <member name="M:UnitClassLibrary.Distance.#ctor(UnitClassLibrary.DistanceEqualityStrategy)">
            <summary>
            Zero Constructor
            </summary>
            <param name="passedStrategy">Strategy to compare equality by</param>
        </member>
        <member name="M:UnitClassLibrary.Distance.#ctor(System.String,UnitClassLibrary.DistanceEqualityStrategy)">
            <summary>
            Accepts any valid architectural string value for input
            </summary>
            <param name="passedArchitecturalString"> Architecturally formatted string to create distance from</param>
            <param name="passedStrategy">Strategy to compare equality by</param>
        </member>
        <member name="M:UnitClassLibrary.Distance.#ctor(UnitClassLibrary.DistanceType,System.Double,UnitClassLibrary.DistanceEqualityStrategy)">
            <summary>
            The standard Unit Constructor that takes the value and the unit type that describes it.
            </summary>
            <param name="passedDistanceType">The unit of distance the input is in</param>
            <param name="passedInput">value of the distance</param>
            <param name="passedStrategy">Strategy to compare equality by</param>
        </member>
        <member name="M:UnitClassLibrary.Distance.#ctor(UnitClassLibrary.Distance)">
            <summary>
            copy constructor
            </summary>
            <param name="passedDistance">Distance objet to copy</param>
        </member>
        <member name="M:UnitClassLibrary.Distance.MakeDistanceWithInches(System.Double)">
            <summary>
            Generator method that constructs Distance with the assumption that the passed value is in inches
            </summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Distance.MakeDistanceWithMillimeters(System.Double)">
            <summary>
            Generator method that constructs Distance with the assumption that the passed value is in milliimeters
            </summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="P:UnitClassLibrary.Distance.Architectural">
            <summary>
            Returns the Distance as a string in AutoCAD notation with sixteenths of an inch percision
            </summary>
        </member>
        <member name="P:UnitClassLibrary.Distance.InternalUnitType">
            <summary>
            This property must be internal to allow for our Just-In-Time conversions to work with the GetValue() method
            </summary>
        </member>
        <member name="P:UnitClassLibrary.Distance.EqualityStrategy">
            <summary>
            The strategy by which this Distance will be compared to another Distance
            </summary>
        </member>
        <member name="T:UnitClassLibrary.DistanceType">
            <summary>
            Enum for specifying the type of unit a Distance is
            </summary>
        </member>
        <member name="T:UnitClassLibrary.DistanceEqualityStrategy">
            <summary>
            delegate that defines the form of 
            </summary>
            <param name="distance1"></param>
            <param name="distance2"></param>
            <returns></returns>
        </member>
        <member name="T:UnitClassLibrary.EqualityStrategyImplementations">
            <summary>
            functions that can be used for a distance object's equals function
            </summary>
        </member>
        <member name="M:UnitClassLibrary.EqualityStrategyImplementations.DefaultPercentageEquality(UnitClassLibrary.Distance,UnitClassLibrary.Distance)">
            <summary>
            Distances are equal if they differ by less than a percentage of the first Distance
            </summary>
            <param name="distance1">first distance being compared</param>
            <param name="distance2">second distance being compared</param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.EqualityStrategyImplementations.DefaultConstantEquality(UnitClassLibrary.Distance,UnitClassLibrary.Distance)">
            <summary>
            Distances are equal if there values are within the passed deviation constant. If they are not within the constant
            </summary>
            <param name="distance1">first distance being compared</param>
            <param name="distance2">second distance being compared</param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.ElectricPotential.#ctor(UnitClassLibrary.ElectricPotentialEqualityStrategy)">
            <summary> Zero Constructor </summary>
        </member>
        <member name="M:UnitClassLibrary.ElectricPotential.#ctor(UnitClassLibrary.ElectricPotentialType,System.Double,UnitClassLibrary.ElectricPotentialEqualityStrategy)">
            <summary> Accepts standard types for input. </summary>
        </member>
        <member name="M:UnitClassLibrary.ElectricPotential.#ctor(UnitClassLibrary.ElectricPotential)">
            <summary> Copy constructor (new unit with same fields as the passed) </summary>
        </member>
        <member name="M:UnitClassLibrary.ElectricPotential.ConvertElectricPotential(UnitClassLibrary.ElectricPotentialType,System.Double,UnitClassLibrary.ElectricPotentialType)">
            <summary>Converts one unit of ElectricPotential to another</summary>
            <param name="typeConvertingTo">input unit type</param>
            <param name="passedValue"></param>
            <param name="typeConvertingFrom">desired output unit type</param>
            <returns>passedValue in desired units</returns>
        </member>
        <member name="M:UnitClassLibrary.ElectricPotential.EqualsWithinDeviationConstant(UnitClassLibrary.ElectricPotential,UnitClassLibrary.ElectricPotential)">
            <summary> value comparison, checks whether the two are equal within a passed accepted equality deviation </summary>
        </member>
        <member name="M:UnitClassLibrary.ElectricPotential.EqualsWithinDeviationPercentage(UnitClassLibrary.ElectricPotential,UnitClassLibrary.ElectricPotential)">
            <summary> value comparison, checks whether the two are equal within a passed accepted equality percentage </summary>
        </member>
        <member name="M:UnitClassLibrary.ElectricPotential.EqualsWithinDistanceEqualityStrategy(UnitClassLibrary.ElectricPotential,UnitClassLibrary.ElectricPotentialEqualityStrategy)">
            <summary> value comparison, checks whether the two are equal within a passed accepted equality percentage </summary>
        </member>
        <member name="M:UnitClassLibrary.ElectricPotential.CompareTo(UnitClassLibrary.ElectricPotential)">
            <summary> This implements the IComparable (ElectricPotential) interface and allows ElectricPotentials to be sorted and such </summary>
        </member>
        <member name="M:UnitClassLibrary.ElectricPotential.CompareTo(System.Object)">
            <summary> This implements the IComparable (ElectricPotential) interface and allows ElectricPotentials to be sorted and such </summary>
        </member>
        <member name="M:UnitClassLibrary.ElectricPotential.op_ExclusiveOr(UnitClassLibrary.ElectricPotential,System.Double)">
            <summary>Raise to power operator</summary>
            <param name="o1"></param>
            <param name="power"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.ElectricPotential.op_Addition(UnitClassLibrary.ElectricPotential,UnitClassLibrary.ElectricPotential)">
            <summary>Returns new unit with sum of two passed units</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.ElectricPotential.op_Subtraction(UnitClassLibrary.ElectricPotential,UnitClassLibrary.ElectricPotential)">
            <summary>Returns new unit with difference of two passed units</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.ElectricPotential.op_Division(UnitClassLibrary.ElectricPotential,UnitClassLibrary.ElectricPotential)">
            <summary>ratio between differences</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.ElectricPotential.op_Multiply(UnitClassLibrary.ElectricPotential,System.Double)">
            <summary>scalar multiplication</summary>
            <param name="o1"></param>
            <param name="multiplier"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.ElectricPotential.op_Multiply(System.Double,UnitClassLibrary.ElectricPotential)">
            <summary>scalar multiplication</summary>
            <param name="o1"></param>
            <param name="multiplier"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.ElectricPotential.op_Division(UnitClassLibrary.ElectricPotential,System.Double)">
            <summary>scalar division</summary>
            <param name="o1"></param>
            <param name="divisor"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.ElectricPotential.op_Inequality(UnitClassLibrary.ElectricPotential,UnitClassLibrary.ElectricPotential)">
            <summary>Not a perfect inequality operator, is only accurate up to Constants.AcceptedEqualityDeviationConstant </summary>
        </member>
        <member name="M:UnitClassLibrary.ElectricPotential.op_Equality(UnitClassLibrary.ElectricPotential,UnitClassLibrary.ElectricPotential)">
            <summary>Not a perfect equality operator, is only accurate up to Constants.AcceptedEqualityDeviationConstant </summary>
        </member>
        <member name="M:UnitClassLibrary.ElectricPotential.op_GreaterThan(UnitClassLibrary.ElectricPotential,UnitClassLibrary.ElectricPotential)">
            <summary>greater than</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.ElectricPotential.op_LessThan(UnitClassLibrary.ElectricPotential,UnitClassLibrary.ElectricPotential)">
            <summary>less than</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.ElectricPotential.op_LessThanOrEqual(UnitClassLibrary.ElectricPotential,UnitClassLibrary.ElectricPotential)">
            <summary>less than or equal to</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.ElectricPotential.op_GreaterThanOrEqual(UnitClassLibrary.ElectricPotential,UnitClassLibrary.ElectricPotential)">
            <summary>greater than or equal to</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.ElectricPotential.GetHashCode">
            <summary>This override determines how this object is inserted into hashtables.</summary>
            <returns>same hashcode as any double would</returns>
        </member>
        <member name="M:UnitClassLibrary.ElectricPotential.ToString">
            <summary>The value and unit in terms of what the object was created with. </summary>
            <returns>Should never return anything</returns>
        </member>
        <member name="M:UnitClassLibrary.ElectricPotential.Equals(System.Object)">
            <summary>calls the Dimension only Equals method</summary>
        </member>
        <member name="M:UnitClassLibrary.ElectricPotential.Equals(UnitClassLibrary.ElectricPotential)">
            <summary>Compares using the function specified by strategy</summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.ElectricPotential.ToString(UnitClassLibrary.ElectricPotentialType)">
            <summary>prints the value and unit type converted to</summary>
            <param name="electricpotentialType"></param>
        </member>
        <member name="M:UnitClassLibrary.ElectricPotential.Negate">
            <summary>Creates a new object that is the negative of this</summary><returns>new object with value equivalent to result</returns>
        </member>
        <member name="M:UnitClassLibrary.ElectricPotential.AbsoluteValue">
            <summary>Creates a new object that is the absolute value of this</summary><returns>new object with value equivalent to result</returns>
        </member>
        <member name="M:UnitClassLibrary.ElectricPotential.RaiseToPower(System.Double)">
            <summary> multiplies itself a given number of times</summary><returns>new object with value equivalent to result</returns>
        </member>
        <member name="M:UnitClassLibrary.ElectricPotential.MakeElectricPotentialWithMicrovolts(System.Double)">
            <summary>Generator method that constructs ElectricPotential with assumption that the passed value is in Microvolts</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.ElectricPotential.MakeElectricPotentialWithMillivolts(System.Double)">
            <summary>Generator method that constructs ElectricPotential with assumption that the passed value is in Millivolts</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.ElectricPotential.MakeElectricPotentialWithVolts(System.Double)">
            <summary>Generator method that constructs ElectricPotential with assumption that the passed value is in Volts</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.ElectricPotential.MakeElectricPotentialWithKilovolts(System.Double)">
            <summary>Generator method that constructs ElectricPotential with assumption that the passed value is in Kilovolts</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.ElectricPotential.MakeElectricPotentialWithMegavolts(System.Double)">
            <summary>Generator method that constructs ElectricPotential with assumption that the passed value is in Megavolts</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.ElectricPotential.MakeElectricPotentialWithPetavolts(System.Double)">
            <summary>Generator method that constructs ElectricPotential with assumption that the passed value is in Petavolts</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="T:UnitClassLibrary.ElectricPotentialType">
            <summary> Enum for specifying the type of unit a ElectricPotential is.</summary>
        </member>
        <member name="T:UnitClassLibrary.ElectricPotentialEqualityStrategy">
            <summary>delegate that defines the form of</summary>
            <param name="electricpotential1"></param>
            <param name="electricpotential2"></param>
            <returns></returns>
        </member>
        <member name="T:UnitClassLibrary.ElectricPotentialDeviationDefaults">
            <summary> Default deviations allowed when comparing ElectricPotential objects </summary>
        </member>
        <member name="P:UnitClassLibrary.ElectricPotentialDeviationDefaults.AcceptedEqualityDeviationDistance">
            <summary> When comparing two electricpotential and deviation is allowed to be within a specific constant. This is that default constant </summary>
        </member>
        <member name="P:UnitClassLibrary.ElectricPotentialDeviationDefaults.ElectricPotentialAcceptedEqualityDeviationDistancePercentage">
            <summary> When comparing two electricpotential and deviation is allowed to be within a percentage of the firstElectricPotential. This is that percentage </summary>
        </member>
        <member name="T:UnitClassLibrary.ElectricPotentialEqualityStrategyImplementations">
            <summary> functions that can be used for a electricpotential object's equals functions </summary>
        </member>
        <member name="M:UnitClassLibrary.ElectricPotentialEqualityStrategyImplementations.DefaultPercentageEquality(UnitClassLibrary.ElectricPotential,UnitClassLibrary.ElectricPotential)">
            <summary> ElectricPotentials are equal if they differ by less than a percentage of the first ElectricPotential </summary>
            <param name="electricpotential1">first electricpotential being compared</param>
            <param name="electricpotential2">second electricpotential being compared</param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.ElectricPotentialEqualityStrategyImplementations.DefaultConstantEquality(UnitClassLibrary.ElectricPotential,UnitClassLibrary.ElectricPotential)">
            <summary> ElectricPotentials are equal if there values are within the passed deviation constant. If they are not within the constant </summary>
            <param name="electricpotential1">first electricpotential being compared</param>
            <param name="electricpotential2">second electricpotential being compared</param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.ElectricCurrent.#ctor(UnitClassLibrary.ElectricCurrentEqualityStrategy)">
            <summary> Zero Constructor </summary>
        </member>
        <member name="M:UnitClassLibrary.ElectricCurrent.#ctor(UnitClassLibrary.ElectricCurrentType,System.Double,UnitClassLibrary.ElectricCurrentEqualityStrategy)">
            <summary> Accepts standard types for input. </summary>
        </member>
        <member name="M:UnitClassLibrary.ElectricCurrent.#ctor(UnitClassLibrary.ElectricCurrent)">
            <summary> Copy constructor (new unit with same fields as the passed) </summary>
        </member>
        <member name="M:UnitClassLibrary.ElectricCurrent.ConvertElectricCurrent(UnitClassLibrary.ElectricCurrentType,System.Double,UnitClassLibrary.ElectricCurrentType)">
            <summary>Converts one unit of ElectricCurrent to another</summary>
            <param name="typeConvertingTo">input unit type</param>
            <param name="passedValue"></param>
            <param name="typeConvertingFrom">desired output unit type</param>
            <returns>passedValue in desired units</returns>
        </member>
        <member name="M:UnitClassLibrary.ElectricCurrent.EqualsWithinDeviationConstant(UnitClassLibrary.ElectricCurrent,UnitClassLibrary.ElectricCurrent)">
            <summary> value comparison, checks whether the two are equal within a passed accepted equality deviation </summary>
        </member>
        <member name="M:UnitClassLibrary.ElectricCurrent.EqualsWithinDeviationPercentage(UnitClassLibrary.ElectricCurrent,UnitClassLibrary.ElectricCurrent)">
            <summary> value comparison, checks whether the two are equal within a passed accepted equality percentage </summary>
        </member>
        <member name="M:UnitClassLibrary.ElectricCurrent.EqualsWithinDistanceEqualityStrategy(UnitClassLibrary.ElectricCurrent,UnitClassLibrary.ElectricCurrentEqualityStrategy)">
            <summary> value comparison, checks whether the two are equal within a passed accepted equality percentage </summary>
        </member>
        <member name="M:UnitClassLibrary.ElectricCurrent.CompareTo(UnitClassLibrary.ElectricCurrent)">
            <summary> This implements the IComparable (ElectricCurrent) interface and allows ElectricCurrents to be sorted and such </summary>
        </member>
        <member name="M:UnitClassLibrary.ElectricCurrent.CompareTo(System.Object)">
            <summary> This implements the IComparable (ElectricCurrent) interface and allows ElectricCurrents to be sorted and such </summary>
        </member>
        <member name="M:UnitClassLibrary.ElectricCurrent.op_ExclusiveOr(UnitClassLibrary.ElectricCurrent,System.Double)">
            <summary>Raise to power operator</summary>
            <param name="o1"></param>
            <param name="power"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.ElectricCurrent.op_Addition(UnitClassLibrary.ElectricCurrent,UnitClassLibrary.ElectricCurrent)">
            <summary>Returns new unit with sum of two passed units</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.ElectricCurrent.op_Subtraction(UnitClassLibrary.ElectricCurrent,UnitClassLibrary.ElectricCurrent)">
            <summary>Returns new unit with difference of two passed units</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.ElectricCurrent.op_Division(UnitClassLibrary.ElectricCurrent,UnitClassLibrary.ElectricCurrent)">
            <summary>ratio between differences</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.ElectricCurrent.op_Multiply(UnitClassLibrary.ElectricCurrent,System.Double)">
            <summary>scalar multiplication</summary>
            <param name="o1"></param>
            <param name="multiplier"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.ElectricCurrent.op_Multiply(System.Double,UnitClassLibrary.ElectricCurrent)">
            <summary>scalar multiplication</summary>
            <param name="o1"></param>
            <param name="multiplier"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.ElectricCurrent.op_Division(UnitClassLibrary.ElectricCurrent,System.Double)">
            <summary>scalar division</summary>
            <param name="o1"></param>
            <param name="divisor"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.ElectricCurrent.op_Inequality(UnitClassLibrary.ElectricCurrent,UnitClassLibrary.ElectricCurrent)">
            <summary>Not a perfect inequality operator, is only accurate up to Constants.AcceptedEqualityDeviationConstant </summary>
        </member>
        <member name="M:UnitClassLibrary.ElectricCurrent.op_Equality(UnitClassLibrary.ElectricCurrent,UnitClassLibrary.ElectricCurrent)">
            <summary>Not a perfect equality operator, is only accurate up to Constants.AcceptedEqualityDeviationConstant </summary>
        </member>
        <member name="M:UnitClassLibrary.ElectricCurrent.op_GreaterThan(UnitClassLibrary.ElectricCurrent,UnitClassLibrary.ElectricCurrent)">
            <summary>greater than</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.ElectricCurrent.op_LessThan(UnitClassLibrary.ElectricCurrent,UnitClassLibrary.ElectricCurrent)">
            <summary>less than</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.ElectricCurrent.op_LessThanOrEqual(UnitClassLibrary.ElectricCurrent,UnitClassLibrary.ElectricCurrent)">
            <summary>less than or equal to</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.ElectricCurrent.op_GreaterThanOrEqual(UnitClassLibrary.ElectricCurrent,UnitClassLibrary.ElectricCurrent)">
            <summary>greater than or equal to</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.ElectricCurrent.GetHashCode">
            <summary>This override determines how this object is inserted into hashtables.</summary>
            <returns>same hashcode as any double would</returns>
        </member>
        <member name="M:UnitClassLibrary.ElectricCurrent.ToString">
            <summary>The value and unit in terms of what the object was created with. </summary>
            <returns>Should never return anything</returns>
        </member>
        <member name="M:UnitClassLibrary.ElectricCurrent.Equals(System.Object)">
            <summary>calls the Dimension only Equals method</summary>
        </member>
        <member name="M:UnitClassLibrary.ElectricCurrent.Equals(UnitClassLibrary.ElectricCurrent)">
            <summary>Compares using the function specified by strategy</summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.ElectricCurrent.ToString(UnitClassLibrary.ElectricCurrentType)">
            <summary>prints the value and unit type converted to</summary>
            <param name="electriccurrentType"></param>
        </member>
        <member name="M:UnitClassLibrary.ElectricCurrent.Negate">
            <summary>Creates a new object that is the negative of this</summary><returns>new object with value equivalent to result</returns>
        </member>
        <member name="M:UnitClassLibrary.ElectricCurrent.AbsoluteValue">
            <summary>Creates a new object that is the absolute value of this</summary><returns>new object with value equivalent to result</returns>
        </member>
        <member name="M:UnitClassLibrary.ElectricCurrent.RaiseToPower(System.Double)">
            <summary> multiplies itself a given number of times</summary><returns>new object with value equivalent to result</returns>
        </member>
        <member name="M:UnitClassLibrary.ElectricCurrent.MakeElectricCurrentWithAmperes(System.Double)">
            <summary>Generator method that constructs ElectricCurrent with assumption that the passed value is in Amperes</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.ElectricCurrent.MakeElectricCurrentWithMilliamperes(System.Double)">
            <summary>Generator method that constructs ElectricCurrent with assumption that the passed value is in Milliamperes</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.ElectricCurrent.MakeElectricCurrentWithMicroamperes(System.Double)">
            <summary>Generator method that constructs ElectricCurrent with assumption that the passed value is in Microamperes</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="T:UnitClassLibrary.ElectricCurrentType">
            <summary> Enum for specifying the type of unit a ElectricCurrent is.</summary>
        </member>
        <member name="T:UnitClassLibrary.ElectricCurrentEqualityStrategy">
            <summary>delegate that defines the form of</summary>
            <param name="electriccurrent1"></param>
            <param name="electriccurrent2"></param>
            <returns></returns>
        </member>
        <member name="T:UnitClassLibrary.ElectricCurrentDeviationDefaults">
            <summary> Default deviations allowed when comparing ElectricCurrent objects </summary>
        </member>
        <member name="P:UnitClassLibrary.ElectricCurrentDeviationDefaults.AcceptedEqualityDeviationDistance">
            <summary> When comparing two electriccurrent and deviation is allowed to be within a specific constant. This is that default constant </summary>
        </member>
        <member name="P:UnitClassLibrary.ElectricCurrentDeviationDefaults.ElectricCurrentAcceptedEqualityDeviationDistancePercentage">
            <summary> When comparing two electriccurrent and deviation is allowed to be within a percentage of the firstElectricCurrent. This is that percentage </summary>
        </member>
        <member name="T:UnitClassLibrary.ElectricCurrentEqualityStrategyImplementations">
            <summary> functions that can be used for a electriccurrent object's equals functions </summary>
        </member>
        <member name="M:UnitClassLibrary.ElectricCurrentEqualityStrategyImplementations.DefaultPercentageEquality(UnitClassLibrary.ElectricCurrent,UnitClassLibrary.ElectricCurrent)">
            <summary> ElectricCurrents are equal if they differ by less than a percentage of the first ElectricCurrent </summary>
            <param name="electriccurrent1">first electriccurrent being compared</param>
            <param name="electriccurrent2">second electriccurrent being compared</param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.ElectricCurrentEqualityStrategyImplementations.DefaultConstantEquality(UnitClassLibrary.ElectricCurrent,UnitClassLibrary.ElectricCurrent)">
            <summary> ElectricCurrents are equal if there values are within the passed deviation constant. If they are not within the constant </summary>
            <param name="electriccurrent1">first electriccurrent being compared</param>
            <param name="electriccurrent2">second electriccurrent being compared</param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Energy.#ctor(UnitClassLibrary.EnergyEqualityStrategy)">
            <summary> Zero Constructor </summary>
        </member>
        <member name="M:UnitClassLibrary.Energy.#ctor(UnitClassLibrary.EnergyType,System.Double,UnitClassLibrary.EnergyEqualityStrategy)">
            <summary> Accepts standard types for input. </summary>
        </member>
        <member name="M:UnitClassLibrary.Energy.#ctor(UnitClassLibrary.Energy)">
            <summary> Copy constructor (new unit with same fields as the passed) </summary>
        </member>
        <member name="M:UnitClassLibrary.Energy.ConvertEnergy(UnitClassLibrary.EnergyType,System.Double,UnitClassLibrary.EnergyType)">
            <summary>Converts one unit of Energy to another</summary>
            <param name="typeConvertingTo">input unit type</param>
            <param name="passedValue"></param>
            <param name="typeConvertingFrom">desired output unit type</param>
            <returns>passedValue in desired units</returns>
        </member>
        <member name="M:UnitClassLibrary.Energy.EqualsWithinDeviationConstant(UnitClassLibrary.Energy,UnitClassLibrary.Energy)">
            <summary> value comparison, checks whether the two are equal within a passed accepted equality deviation </summary>
        </member>
        <member name="M:UnitClassLibrary.Energy.EqualsWithinDeviationPercentage(UnitClassLibrary.Energy,UnitClassLibrary.Energy)">
            <summary> value comparison, checks whether the two are equal within a passed accepted equality percentage </summary>
        </member>
        <member name="M:UnitClassLibrary.Energy.EqualsWithinDistanceEqualityStrategy(UnitClassLibrary.Energy,UnitClassLibrary.EnergyEqualityStrategy)">
            <summary> value comparison, checks whether the two are equal within a passed accepted equality percentage </summary>
        </member>
        <member name="M:UnitClassLibrary.Energy.CompareTo(UnitClassLibrary.Energy)">
            <summary> This implements the IComparable (Energy) interface and allows Energys to be sorted and such </summary>
        </member>
        <member name="M:UnitClassLibrary.Energy.CompareTo(System.Object)">
            <summary> This implements the IComparable (Energy) interface and allows Energys to be sorted and such </summary>
        </member>
        <member name="M:UnitClassLibrary.Energy.op_ExclusiveOr(UnitClassLibrary.Energy,System.Double)">
            <summary>Raise to power operator</summary>
            <param name="o1"></param>
            <param name="power"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Energy.op_Addition(UnitClassLibrary.Energy,UnitClassLibrary.Energy)">
            <summary>Returns new unit with sum of two passed units</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Energy.op_Subtraction(UnitClassLibrary.Energy,UnitClassLibrary.Energy)">
            <summary>Returns new unit with difference of two passed units</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Energy.op_Division(UnitClassLibrary.Energy,UnitClassLibrary.Energy)">
            <summary>ratio between differences</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Energy.op_Multiply(UnitClassLibrary.Energy,System.Double)">
            <summary>scalar multiplication</summary>
            <param name="o1"></param>
            <param name="multiplier"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Energy.op_Multiply(System.Double,UnitClassLibrary.Energy)">
            <summary>scalar multiplication</summary>
            <param name="o1"></param>
            <param name="multiplier"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Energy.op_Division(UnitClassLibrary.Energy,System.Double)">
            <summary>scalar division</summary>
            <param name="o1"></param>
            <param name="divisor"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Energy.op_Inequality(UnitClassLibrary.Energy,UnitClassLibrary.Energy)">
            <summary>Not a perfect inequality operator, is only accurate up to Constants.AcceptedEqualityDeviationConstant </summary>
        </member>
        <member name="M:UnitClassLibrary.Energy.op_Equality(UnitClassLibrary.Energy,UnitClassLibrary.Energy)">
            <summary>Not a perfect equality operator, is only accurate up to Constants.AcceptedEqualityDeviationConstant </summary>
        </member>
        <member name="M:UnitClassLibrary.Energy.op_GreaterThan(UnitClassLibrary.Energy,UnitClassLibrary.Energy)">
            <summary>greater than</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Energy.op_LessThan(UnitClassLibrary.Energy,UnitClassLibrary.Energy)">
            <summary>less than</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Energy.op_LessThanOrEqual(UnitClassLibrary.Energy,UnitClassLibrary.Energy)">
            <summary>less than or equal to</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Energy.op_GreaterThanOrEqual(UnitClassLibrary.Energy,UnitClassLibrary.Energy)">
            <summary>greater than or equal to</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Energy.GetHashCode">
            <summary>This override determines how this object is inserted into hashtables.</summary>
            <returns>same hashcode as any double would</returns>
        </member>
        <member name="M:UnitClassLibrary.Energy.ToString">
            <summary>The value and unit in terms of what the object was created with. </summary>
            <returns>Should never return anything</returns>
        </member>
        <member name="M:UnitClassLibrary.Energy.Equals(System.Object)">
            <summary>calls the Dimension only Equals method</summary>
        </member>
        <member name="M:UnitClassLibrary.Energy.Equals(UnitClassLibrary.Energy)">
            <summary>Compares using the function specified by strategy</summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Energy.ToString(UnitClassLibrary.EnergyType)">
            <summary>prints the value and unit type converted to</summary>
            <param name="energyType"></param>
        </member>
        <member name="M:UnitClassLibrary.Energy.Negate">
            <summary>Creates a new object that is the negative of this</summary><returns>new object with value equivalent to result</returns>
        </member>
        <member name="M:UnitClassLibrary.Energy.AbsoluteValue">
            <summary>Creates a new object that is the absolute value of this</summary><returns>new object with value equivalent to result</returns>
        </member>
        <member name="M:UnitClassLibrary.Energy.RaiseToPower(System.Double)">
            <summary> multiplies itself a given number of times</summary><returns>new object with value equivalent to result</returns>
        </member>
        <member name="M:UnitClassLibrary.Energy.MakeEnergyWithCalories(System.Double)">
            <summary>Generator method that constructs Energy with assumption that the passed value is in Calories</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Energy.MakeEnergyWithKilocalories(System.Double)">
            <summary>Generator method that constructs Energy with assumption that the passed value is in Kilocalories</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Energy.MakeEnergyWithErgs(System.Double)">
            <summary>Generator method that constructs Energy with assumption that the passed value is in Ergs</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Energy.MakeEnergyWithFootpounds(System.Double)">
            <summary>Generator method that constructs Energy with assumption that the passed value is in Footpounds</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Energy.MakeEnergyWithJoules(System.Double)">
            <summary>Generator method that constructs Energy with assumption that the passed value is in Joules</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="T:UnitClassLibrary.EnergyType">
            <summary> Enum for specifying the type of unit a Energy is.</summary>
        </member>
        <member name="T:UnitClassLibrary.EnergyEqualityStrategy">
            <summary>delegate that defines the form of</summary>
            <param name="energy1"></param>
            <param name="energy2"></param>
            <returns></returns>
        </member>
        <member name="T:UnitClassLibrary.EnergyDeviationDefaults">
            <summary> Default deviations allowed when comparing Energy objects </summary>
        </member>
        <member name="P:UnitClassLibrary.EnergyDeviationDefaults.AcceptedEqualityDeviationDistance">
            <summary> When comparing two energy and deviation is allowed to be within a specific constant. This is that default constant </summary>
        </member>
        <member name="P:UnitClassLibrary.EnergyDeviationDefaults.EnergyAcceptedEqualityDeviationDistancePercentage">
            <summary> When comparing two energy and deviation is allowed to be within a percentage of the firstEnergy. This is that percentage </summary>
        </member>
        <member name="T:UnitClassLibrary.EnergyEqualityStrategyImplementations">
            <summary> functions that can be used for a energy object's equals functions </summary>
        </member>
        <member name="M:UnitClassLibrary.EnergyEqualityStrategyImplementations.DefaultPercentageEquality(UnitClassLibrary.Energy,UnitClassLibrary.Energy)">
            <summary> Energys are equal if they differ by less than a percentage of the first Energy </summary>
            <param name="energy1">first energy being compared</param>
            <param name="energy2">second energy being compared</param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.EnergyEqualityStrategyImplementations.DefaultConstantEquality(UnitClassLibrary.Energy,UnitClassLibrary.Energy)">
            <summary> Energys are equal if there values are within the passed deviation constant. If they are not within the constant </summary>
            <param name="energy1">first energy being compared</param>
            <param name="energy2">second energy being compared</param>
            <returns></returns>
        </member>
        <member name="T:UnitClassLibrary.AngleListExtensionMethods">
            <summary>
            Extension methods for Lists of type Angle
            </summary>
        </member>
        <member name="M:UnitClassLibrary.AngleListExtensionMethods.SumTotal(System.Collections.Generic.List{UnitClassLibrary.Angle})">
            <summary>
            Adds all of the angles in the list and returns the sum.
            </summary>
            <param name="passedAngleList">this</param>
            <returns>Total of all Angles in the list</returns>
        </member>
        <member name="T:UnitClassLibrary.Area">
            <summary>
            Represents two dimensional distance
            </summary>
        </member>
        <member name="M:UnitClassLibrary.Area.#ctor">
            <summary>
            sets the area to 0
            </summary>
        </member>
        <member name="M:UnitClassLibrary.Area.#ctor(UnitClassLibrary.Distance,UnitClassLibrary.Distance)">
            <summary>
            Take two Distances and make them into an area
            </summary>
            <param name="d1"></param>
            <param name="d2"></param>
        </member>
        <member name="M:UnitClassLibrary.Area.#ctor(UnitClassLibrary.AreaType,System.Double)">
            <summary>
            sets the area to the passed double with the passed unit type
            </summary>
            <param name="areaType">passed unit type</param>
            <param name="passedValue">area of unit type</param>
        </member>
        <member name="M:UnitClassLibrary.Area.GetValue(UnitClassLibrary.AreaType)">
            <summary>
            returns the property specified by the AreaType
            </summary>
            <param name="Units"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Area.retrieveAsExternalUnit(UnitClassLibrary.AreaType)">
            <summary>
            Uses AreaConverter to convert to the area requested from intrinsic inches
            </summary>
            <param name="areaType">unit type to retrieve area in</param>
            <returns>area in specified unit type</returns>
        </member>
        <member name="M:UnitClassLibrary.Area.ConvertArea(UnitClassLibrary.AreaType,System.Double,UnitClassLibrary.AreaType)">
            <summary>
            universal converter to and from area types
            </summary>
            <param name="fromType">unit type to convert from</param>
            <param name="passedValue">value to convert</param>
            <param name="toType">unit type to convert to</param>
            <returns>double of area in toType</returns>
        </member>
        <member name="M:UnitClassLibrary.Area.op_Addition(UnitClassLibrary.Area,UnitClassLibrary.Area)">
            <summary>
            adds two areas together
            </summary>
            <param name="a1">area 1</param>
            <param name="a2">area 2</param>
            <returns>sum of two areas</returns>
        </member>
        <member name="M:UnitClassLibrary.Area.op_Subtraction(UnitClassLibrary.Area,UnitClassLibrary.Area)">
            <summary>
            subtracts an area from the other
            </summary>
            <param name="a1">area to be subtracted from</param>
            <param name="a2">area to subtract</param>
            <returns>d1 - d2</returns>
        </member>
        <member name="M:UnitClassLibrary.Area.op_Equality(UnitClassLibrary.Area,UnitClassLibrary.Area)">
            <summary>
            checks equality of two areas
            </summary>
            <param name="a1">area 1</param>
            <param name="a2">area 2</param>
            <returns>true if the areas are equal</returns>
        </member>
        <member name="M:UnitClassLibrary.Area.op_Inequality(UnitClassLibrary.Area,UnitClassLibrary.Area)">
            <summary>
            checks inequality of two areas
            </summary>
            <param name="a1">area 1</param>
            <param name="a2">area 2</param>
            <returns>true if the areas are not equal</returns>
        </member>
        <member name="M:UnitClassLibrary.Area.op_GreaterThan(UnitClassLibrary.Area,UnitClassLibrary.Area)">
            <summary>
            checks specific inequality of two areas
            </summary>
            <param name="a1">area supposed to be larger</param>
            <param name="a2">area supposed to be smaller</param>
            <returns>whether the first area is larger than second area</returns>
        </member>
        <member name="M:UnitClassLibrary.Area.op_LessThan(UnitClassLibrary.Area,UnitClassLibrary.Area)">
            <summary>
            checks specific inequality of two areas
            </summary>
            <param name="a1">area supposed to be smaller</param>
            <param name="a2">area supposed to be larger</param>
            <returns>whether the first area is smaller than second area</returns>
        </member>
        <member name="M:UnitClassLibrary.Area.GetHashCode">
            <summary>
            This override determines how this object is inserted into hashtables.
            </summary>
            <returns>same hashcode as any double would</returns>
        </member>
        <member name="M:UnitClassLibrary.Area.ToString">
            <summary>
            The value and unit in terms of what the object was created with. 
            If you want it in a different unit use ToString(AreaType)
            </summary>
            <returns>Should never return anything</returns>
        </member>
        <member name="M:UnitClassLibrary.Area.Equals(System.Object)">
            <summary>
            checks equality within the Accepted Equality Deviation
            </summary>
            <param name="obj">object to check equality against</param>
            <returns>true if the areas are equal</returns>
        </member>
        <member name="M:UnitClassLibrary.Area.CompareTo(UnitClassLibrary.Area)">
            <summary>
            This implements the IComparable interface and allows Areas to be sorted and such
            </summary>
            <param name="other">area to check against</param>
            <returns>0 if equal; 1 if this greater than other; -1 if this less than other</returns>
        </member>
        <member name="P:UnitClassLibrary.Area.InternalUnitType">
            <summary>
            This property must be internal to allow for our Just-In-Time conversions to work with the GetValue() method
            </summary>
        </member>
        <member name="P:UnitClassLibrary.Area.MillimetersSquared">
            <summary>
            uses millimeters squared as a property and retrieves as an external unit when necessary
            </summary>
        </member>
        <member name="P:UnitClassLibrary.Area.CentimetersSquared">
            <summary>
            uses centimeters squared as a property and retrieves as an external unit when necessary
            </summary>
        </member>
        <member name="P:UnitClassLibrary.Area.InchesSquared">
            <summary>
            uses inches squared as a property and retrieves it as an external unit when necessary
            </summary>
        </member>
        <member name="P:UnitClassLibrary.Area.FeetSquared">
            <summary>
            uses feet squared as a property and retrieves as an external unit when necessary
            </summary>
        </member>
        <member name="P:UnitClassLibrary.Area.YardsSquared">
            <summary>
            uses yards squared as a property and retrieves as an external unit when necessary
            </summary>
        </member>
        <member name="P:UnitClassLibrary.Area.MetersSquared">
            <summary>
            uses meters squared as a property and retrieves as an external unit when necessary
            </summary>
        </member>
        <member name="P:UnitClassLibrary.Area.KilometersSquared">
            <summary>
            uses kilometers squared as a property and retrieves as an external unit when necessary
            </summary>
        </member>
        <member name="P:UnitClassLibrary.Area.MilesSquared">
            <summary>
            uses miles squared as a property and retrieves as an external unit when necessary
            </summary>
        </member>
        <member name="T:UnitClassLibrary.AreaType">
            <summary>
            Enum for specifying the type of unit an area is
            </summary>
        </member>
        <member name="T:UnitClassLibrary.PowerType">
            <summary>
            Enum for specifying the type of unit a power is
            </summary>
        </member>
        <member name="T:UnitClassLibrary.StressType">
            <summary>
            Enum for specifying the type of unit a stress is
            </summary>
        </member>
        <member name="T:UnitClassLibrary.VolumeType">
            <summary>
            Enum for specifying the type of unit a volume is
            </summary>	
        </member>
        <member name="M:UnitClassLibrary.Force.#ctor(UnitClassLibrary.ForceEqualityStrategy)">
            <summary> Zero Constructor </summary>
        </member>
        <member name="M:UnitClassLibrary.Force.#ctor(UnitClassLibrary.ForceType,System.Double,UnitClassLibrary.ForceEqualityStrategy)">
            <summary> Accepts standard types for input. </summary>
        </member>
        <member name="M:UnitClassLibrary.Force.#ctor(UnitClassLibrary.Force)">
            <summary> Copy constructor (new unit with same fields as the passed) </summary>
        </member>
        <member name="M:UnitClassLibrary.Force.ConvertForce(UnitClassLibrary.ForceType,System.Double,UnitClassLibrary.ForceType)">
            <summary>Converts one unit of Force to another</summary>
            <param name="typeConvertingTo">input unit type</param>
            <param name="passedValue"></param>
            <param name="typeConvertingFrom">desired output unit type</param>
            <returns>passedValue in desired units</returns>
        </member>
        <member name="M:UnitClassLibrary.Force.EqualsWithinDeviationConstant(UnitClassLibrary.Force,UnitClassLibrary.Force)">
            <summary> value comparison, checks whether the two are equal within a passed accepted equality deviation </summary>
        </member>
        <member name="M:UnitClassLibrary.Force.EqualsWithinDeviationPercentage(UnitClassLibrary.Force,UnitClassLibrary.Force)">
            <summary> value comparison, checks whether the two are equal within a passed accepted equality percentage </summary>
        </member>
        <member name="M:UnitClassLibrary.Force.EqualsWithinDistanceEqualityStrategy(UnitClassLibrary.Force,UnitClassLibrary.ForceEqualityStrategy)">
            <summary> value comparison, checks whether the two are equal within a passed accepted equality percentage </summary>
        </member>
        <member name="M:UnitClassLibrary.Force.CompareTo(UnitClassLibrary.Force)">
            <summary> This implements the IComparable (Force) interface and allows Forces to be sorted and such </summary>
        </member>
        <member name="M:UnitClassLibrary.Force.CompareTo(System.Object)">
            <summary> This implements the IComparable (Force) interface and allows Forces to be sorted and such </summary>
        </member>
        <member name="M:UnitClassLibrary.Force.op_ExclusiveOr(UnitClassLibrary.Force,System.Double)">
            <summary>Raise to power operator</summary>
            <param name="o1"></param>
            <param name="power"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Force.op_Addition(UnitClassLibrary.Force,UnitClassLibrary.Force)">
            <summary>Returns new unit with sum of two passed units</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Force.op_Subtraction(UnitClassLibrary.Force,UnitClassLibrary.Force)">
            <summary>Returns new unit with difference of two passed units</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Force.op_Division(UnitClassLibrary.Force,UnitClassLibrary.Force)">
            <summary>ratio between differences</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Force.op_Multiply(UnitClassLibrary.Force,System.Double)">
            <summary>scalar multiplication</summary>
            <param name="o1"></param>
            <param name="multiplier"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Force.op_Multiply(System.Double,UnitClassLibrary.Force)">
            <summary>scalar multiplication</summary>
            <param name="o1"></param>
            <param name="multiplier"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Force.op_Division(UnitClassLibrary.Force,System.Double)">
            <summary>scalar division</summary>
            <param name="o1"></param>
            <param name="divisor"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Force.op_Inequality(UnitClassLibrary.Force,UnitClassLibrary.Force)">
            <summary>Not a perfect inequality operator, is only accurate up to Constants.AcceptedEqualityDeviationConstant </summary>
        </member>
        <member name="M:UnitClassLibrary.Force.op_Equality(UnitClassLibrary.Force,UnitClassLibrary.Force)">
            <summary>Not a perfect equality operator, is only accurate up to Constants.AcceptedEqualityDeviationConstant </summary>
        </member>
        <member name="M:UnitClassLibrary.Force.op_GreaterThan(UnitClassLibrary.Force,UnitClassLibrary.Force)">
            <summary>greater than</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Force.op_LessThan(UnitClassLibrary.Force,UnitClassLibrary.Force)">
            <summary>less than</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Force.op_LessThanOrEqual(UnitClassLibrary.Force,UnitClassLibrary.Force)">
            <summary>less than or equal to</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Force.op_GreaterThanOrEqual(UnitClassLibrary.Force,UnitClassLibrary.Force)">
            <summary>greater than or equal to</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Force.GetHashCode">
            <summary>This override determines how this object is inserted into hashtables.</summary>
            <returns>same hashcode as any double would</returns>
        </member>
        <member name="M:UnitClassLibrary.Force.ToString">
            <summary>The value and unit in terms of what the object was created with. </summary>
            <returns>Should never return anything</returns>
        </member>
        <member name="M:UnitClassLibrary.Force.Equals(System.Object)">
            <summary>calls the Dimension only Equals method</summary>
        </member>
        <member name="M:UnitClassLibrary.Force.Equals(UnitClassLibrary.Force)">
            <summary>Compares using the function specified by strategy</summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Force.ToString(UnitClassLibrary.ForceType)">
            <summary>prints the value and unit type converted to</summary>
            <param name="forceType"></param>
        </member>
        <member name="M:UnitClassLibrary.Force.Negate">
            <summary>Creates a new object that is the negative of this</summary><returns>new object with value equivalent to result</returns>
        </member>
        <member name="M:UnitClassLibrary.Force.AbsoluteValue">
            <summary>Creates a new object that is the absolute value of this</summary><returns>new object with value equivalent to result</returns>
        </member>
        <member name="M:UnitClassLibrary.Force.RaiseToPower(System.Double)">
            <summary> multiplies itself a given number of times</summary><returns>new object with value equivalent to result</returns>
        </member>
        <member name="M:UnitClassLibrary.Force.MakeForceWithNewtons(System.Double)">
            <summary>Generator method that constructs Force with assumption that the passed value is in Newtons</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Force.MakeForceWithPounds(System.Double)">
            <summary>Generator method that constructs Force with assumption that the passed value is in Pounds</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Force.MakeForceWithKips(System.Double)">
            <summary>Generator method that constructs Force with assumption that the passed value is in Kips</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="T:UnitClassLibrary.ForceType">
            <summary> Enum for specifying the type of unit a Force is.</summary>
        </member>
        <member name="T:UnitClassLibrary.ForceEqualityStrategy">
            <summary>delegate that defines the form of</summary>
            <param name="force1"></param>
            <param name="force2"></param>
            <returns></returns>
        </member>
        <member name="T:UnitClassLibrary.ForceDeviationDefaults">
            <summary> Default deviations allowed when comparing Force objects </summary>
        </member>
        <member name="P:UnitClassLibrary.ForceDeviationDefaults.AcceptedEqualityDeviationDistance">
            <summary> When comparing two force and deviation is allowed to be within a specific constant. This is that default constant </summary>
        </member>
        <member name="P:UnitClassLibrary.ForceDeviationDefaults.ForceAcceptedEqualityDeviationDistancePercentage">
            <summary> When comparing two force and deviation is allowed to be within a percentage of the firstForce. This is that percentage </summary>
        </member>
        <member name="T:UnitClassLibrary.ForceEqualityStrategyImplementations">
            <summary> functions that can be used for a force object's equals functions </summary>
        </member>
        <member name="M:UnitClassLibrary.ForceEqualityStrategyImplementations.DefaultPercentageEquality(UnitClassLibrary.Force,UnitClassLibrary.Force)">
            <summary> Forces are equal if they differ by less than a percentage of the first Force </summary>
            <param name="force1">first force being compared</param>
            <param name="force2">second force being compared</param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.ForceEqualityStrategyImplementations.DefaultConstantEquality(UnitClassLibrary.Force,UnitClassLibrary.Force)">
            <summary> Forces are equal if there values are within the passed deviation constant. If they are not within the constant </summary>
            <param name="force1">first force being compared</param>
            <param name="force2">second force being compared</param>
            <returns></returns>
        </member>
        <member name="T:UnitClassLibrary.MassType">
            <summary> Enum for specifying the type of unit a Mass is.</summary>
        </member>
        <member name="M:UnitClassLibrary.Mass.ToString(UnitClassLibrary.MassType)">
            <summary>prints the value and unit type converted to</summary>
            <param name="massType"></param>
        </member>
        <member name="M:UnitClassLibrary.Mass.Negate">
            <summary>Creates a new object that is the negative of this</summary><returns>new object with value equivalent to result</returns>
        </member>
        <member name="M:UnitClassLibrary.Mass.AbsoluteValue">
            <summary>Creates a new object that is the absolute value of this</summary><returns>new object with value equivalent to result</returns>
        </member>
        <member name="M:UnitClassLibrary.Mass.RaiseToPower(System.Double)">
            <summary> multiplies itself a given number of times</summary><returns>new object with value equivalent to result</returns>
        </member>
        <member name="M:UnitClassLibrary.Mass.op_ExclusiveOr(UnitClassLibrary.Mass,System.Double)">
            <summary>Raise to power operator</summary>
            <param name="o1"></param>
            <param name="power"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Mass.op_Addition(UnitClassLibrary.Mass,UnitClassLibrary.Mass)">
            <summary>Returns new unit with sum of two passed units</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Mass.op_Subtraction(UnitClassLibrary.Mass,UnitClassLibrary.Mass)">
            <summary>Returns new unit with difference of two passed units</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Mass.op_Division(UnitClassLibrary.Mass,UnitClassLibrary.Mass)">
            <summary>ratio between differences</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Mass.op_Multiply(UnitClassLibrary.Mass,System.Double)">
            <summary>scalar multiplication</summary>
            <param name="o1"></param>
            <param name="multiplier"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Mass.op_Multiply(System.Double,UnitClassLibrary.Mass)">
            <summary>scalar multiplication</summary>
            <param name="o1"></param>
            <param name="multiplier"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Mass.op_Division(UnitClassLibrary.Mass,System.Double)">
            <summary>scalar division</summary>
            <param name="o1"></param>
            <param name="divisor"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Mass.op_Inequality(UnitClassLibrary.Mass,UnitClassLibrary.Mass)">
            <summary>Not a perfect inequality operator, is only accurate up to Constants.AcceptedEqualityDeviationConstant </summary>
        </member>
        <member name="M:UnitClassLibrary.Mass.op_Equality(UnitClassLibrary.Mass,UnitClassLibrary.Mass)">
            <summary>Not a perfect equality operator, is only accurate up to Constants.AcceptedEqualityDeviationConstant </summary>
        </member>
        <member name="M:UnitClassLibrary.Mass.op_GreaterThan(UnitClassLibrary.Mass,UnitClassLibrary.Mass)">
            <summary>greater than</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Mass.op_LessThan(UnitClassLibrary.Mass,UnitClassLibrary.Mass)">
            <summary>less than</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Mass.op_LessThanOrEqual(UnitClassLibrary.Mass,UnitClassLibrary.Mass)">
            <summary>less than or equal to</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Mass.op_GreaterThanOrEqual(UnitClassLibrary.Mass,UnitClassLibrary.Mass)">
            <summary>greater than or equal to</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Mass.GetHashCode">
            <summary>This override determines how this object is inserted into hashtables.</summary>
            <returns>same hashcode as any double would</returns>
        </member>
        <member name="M:UnitClassLibrary.Mass.ToString">
            <summary>The value and unit in terms of what the object was created with. </summary>
            <returns>Should never return anything</returns>
        </member>
        <member name="M:UnitClassLibrary.Mass.Equals(System.Object)">
            <summary>calls the Dimension only Equals method</summary>
        </member>
        <member name="M:UnitClassLibrary.Mass.Equals(UnitClassLibrary.Mass)">
            <summary>Compares using the function specified by strategy</summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Mass.CompareTo(UnitClassLibrary.Mass)">
            <summary> This implements the IComparable (Mass) interface and allows Masss to be sorted and such </summary>
        </member>
        <member name="M:UnitClassLibrary.Mass.CompareTo(System.Object)">
            <summary> This implements the IComparable (Mass) interface and allows Masss to be sorted and such </summary>
        </member>
        <member name="M:UnitClassLibrary.Mass.EqualsWithinDeviationConstant(UnitClassLibrary.Mass,UnitClassLibrary.Mass)">
            <summary> value comparison, checks whether the two are equal within a passed accepted equality deviation </summary>
        </member>
        <member name="M:UnitClassLibrary.Mass.EqualsWithinDeviationPercentage(UnitClassLibrary.Mass,UnitClassLibrary.Mass)">
            <summary> value comparison, checks whether the two are equal within a passed accepted equality percentage </summary>
        </member>
        <member name="M:UnitClassLibrary.Mass.EqualsWithinDistanceEqualityStrategy(UnitClassLibrary.Mass,UnitClassLibrary.MassEqualityStrategy)">
            <summary> value comparison, checks whether the two are equal within a passed accepted equality percentage </summary>
        </member>
        <member name="M:UnitClassLibrary.Mass.ConvertMass(UnitClassLibrary.MassType,System.Double,UnitClassLibrary.MassType)">
            <summary>
            Converts any Unit of mass into another
            </summary>
            <param name="typeConvertingFrom">input unit type</param>
            <param name="typeConvertingTo">desired output unit type</param>
            <param name="passedValue">Desired amount of mass in typeConvertingTo units</param>
            <returns>passedValue in desired units</returns>
            { Gram, MetricTon, Milligram, Microgram, LongTon, ShortTon, Stone, Pound, Ounce }
        </member>
        <member name="M:UnitClassLibrary.Mass.#ctor(UnitClassLibrary.MassEqualityStrategy)">
            <summary> Zero Constructor </summary>
        </member>
        <member name="M:UnitClassLibrary.Mass.#ctor(UnitClassLibrary.MassType,System.Double,UnitClassLibrary.MassEqualityStrategy)">
            <summary> Accepts standard types for input. </summary>
        </member>
        <member name="M:UnitClassLibrary.Mass.#ctor(UnitClassLibrary.Mass)">
            <summary> Copy constructor (new unit with same fields as the passed) </summary>
        </member>
        <member name="M:UnitClassLibrary.Mass.MakeMassWithGrams(System.Double)">
            <summary>Generator method that constructs Mass with assumption that the passed value is in Grams</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Mass.MakeMassWithKilograms(System.Double)">
            <summary>Generator method that constructs Mass with assumption that the passed value is in Kilograms</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Mass.MakeMassWithMetricTons(System.Double)">
            <summary>Generator method that constructs Mass with assumption that the passed value is in MetricTons</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Mass.MakeMassWithMilligrams(System.Double)">
            <summary>Generator method that constructs Mass with assumption that the passed value is in Milligrams</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Mass.MakeMassWithMicrograms(System.Double)">
            <summary>Generator method that constructs Mass with assumption that the passed value is in Micrograms</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Mass.MakeMassWithLongTons(System.Double)">
            <summary>Generator method that constructs Mass with assumption that the passed value is in LongTons</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Mass.MakeMassWithShortTons(System.Double)">
            <summary>Generator method that constructs Mass with assumption that the passed value is in ShortTons</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Mass.MakeMassWithStones(System.Double)">
            <summary>Generator method that constructs Mass with assumption that the passed value is in Stones</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Mass.MakeMassWithPounds(System.Double)">
            <summary>Generator method that constructs Mass with assumption that the passed value is in Pounds</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Mass.MakeMassWithOunces(System.Double)">
            <summary>Generator method that constructs Mass with assumption that the passed value is in Ounces</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="T:UnitClassLibrary.MassEqualityStrategy">
            <summary>delegate that defines the form of</summary>
            <param name="mass1"></param>
            <param name="mass2"></param>
            <returns></returns>
        </member>
        <member name="T:UnitClassLibrary.MassDeviationDefaults">
            <summary> Default deviations allowed when comparing Mass objects </summary>
        </member>
        <member name="P:UnitClassLibrary.MassDeviationDefaults.AcceptedEqualityDeviationDistance">
            <summary> When comparing two mass and deviation is allowed to be within a specific constant. This is that default constant </summary>
        </member>
        <member name="P:UnitClassLibrary.MassDeviationDefaults.MassAcceptedEqualityDeviationDistancePercentage">
            <summary> When comparing two mass and deviation is allowed to be within a percentage of the firstMass. This is that percentage </summary>
        </member>
        <member name="T:UnitClassLibrary.MassEqualityStrategyImplementations">
            <summary> functions that can be used for a mass object's equals functions </summary>
        </member>
        <member name="M:UnitClassLibrary.MassEqualityStrategyImplementations.DefaultPercentageEquality(UnitClassLibrary.Mass,UnitClassLibrary.Mass)">
            <summary> Masss are equal if they differ by less than a percentage of the first Mass </summary>
            <param name="mass1">first mass being compared</param>
            <param name="mass2">second mass being compared</param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.MassEqualityStrategyImplementations.DefaultConstantEquality(UnitClassLibrary.Mass,UnitClassLibrary.Mass)">
            <summary> Masss are equal if there values are within the passed deviation constant. If they are not within the constant </summary>
            <param name="mass1">first mass being compared</param>
            <param name="mass2">second mass being compared</param>
            <returns></returns>
        </member>
        <member name="T:UnitClassLibrary.MomentOfIntertiaUnit">
            <summary>
            
            </summary>
        </member>
        <member name="M:UnitClassLibrary.MomentOfIntertiaUnit.#ctor(UnitClassLibrary.Distance)">
            <summary>
            
            </summary>
            <param name="passedLengthToFourthPower"></param>
        </member>
        <member name="P:UnitClassLibrary.MomentOfIntertiaUnit.LengthToFourthPower">
            <summary>
            
            </summary>
        </member>
        <member name="M:UnitClassLibrary.Moment.#ctor(UnitClassLibrary.MomentEqualityStrategy)">
            <summary> Zero Constructor </summary>
        </member>
        <member name="M:UnitClassLibrary.Moment.#ctor(UnitClassLibrary.Force,UnitClassLibrary.Distance,UnitClassLibrary.MomentEqualityStrategy)">
            <summary> constructor that creates moment based on the passed units </summary>
        </member>
        <member name="M:UnitClassLibrary.Moment.#ctor(UnitClassLibrary.MomentType,System.Double,UnitClassLibrary.MomentEqualityStrategy)">
            <summary> Copy constructor (new unit with same fields as the passed) </summary>
        </member>
        <member name="M:UnitClassLibrary.Moment.EqualsWithinDeviationConstant(UnitClassLibrary.Moment,UnitClassLibrary.Moment)">
            <summary> value comparison, checks whether the two are equal within a passed accepted equality deviation </summary>
        </member>
        <member name="M:UnitClassLibrary.Moment.EqualsWithinDeviationPercentage(UnitClassLibrary.Moment,UnitClassLibrary.Moment)">
            <summary> value comparison, checks whether the two are equal within a passed accepted equality percentage </summary>
        </member>
        <member name="M:UnitClassLibrary.Moment.EqualsWithinDistanceEqualityStrategy(UnitClassLibrary.Moment,UnitClassLibrary.MomentEqualityStrategy)">
            <summary> value comparison, checks whether the two are equal within a passed accepted equality percentage </summary>
        </member>
        <member name="M:UnitClassLibrary.Moment.CompareTo(UnitClassLibrary.Moment)">
            <summary> This implements the IComparable (Moment) interface and allows Moments to be sorted and such </summary>
        </member>
        <member name="M:UnitClassLibrary.Moment.CompareTo(System.Object)">
            <summary> This implements the IComparable (Moment) interface and allows Moments to be sorted and such </summary>
        </member>
        <member name="M:UnitClassLibrary.Moment.op_ExclusiveOr(UnitClassLibrary.Moment,System.Double)">
            <summary>Raise to power operator</summary>
            <param name="o1"></param>
            <param name="power"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Moment.op_Addition(UnitClassLibrary.Moment,UnitClassLibrary.Moment)">
            <summary>Returns new unit with sum of two passed units</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Moment.op_Subtraction(UnitClassLibrary.Moment,UnitClassLibrary.Moment)">
            <summary>Returns new unit with difference of two passed units</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Moment.op_Division(UnitClassLibrary.Moment,UnitClassLibrary.Moment)">
            <summary>ratio between differences</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Moment.op_Multiply(UnitClassLibrary.Moment,System.Double)">
            <summary>scalar multiplication</summary>
            <param name="o1"></param>
            <param name="multiplier"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Moment.op_Multiply(System.Double,UnitClassLibrary.Moment)">
            <summary>scalar multiplication</summary>
            <param name="o1"></param>
            <param name="multiplier"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Moment.op_Division(UnitClassLibrary.Moment,System.Double)">
            <summary>scalar division</summary>
            <param name="o1"></param>
            <param name="divisor"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Moment.op_Inequality(UnitClassLibrary.Moment,UnitClassLibrary.Moment)">
            <summary>Not a perfect inequality operator, is only accurate up to Constants.AcceptedEqualityDeviationConstant </summary>
        </member>
        <member name="M:UnitClassLibrary.Moment.op_Equality(UnitClassLibrary.Moment,UnitClassLibrary.Moment)">
            <summary>Not a perfect equality operator, is only accurate up to Constants.AcceptedEqualityDeviationConstant </summary>
        </member>
        <member name="M:UnitClassLibrary.Moment.op_GreaterThan(UnitClassLibrary.Moment,UnitClassLibrary.Moment)">
            <summary>greater than</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Moment.op_LessThan(UnitClassLibrary.Moment,UnitClassLibrary.Moment)">
            <summary>less than</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Moment.op_LessThanOrEqual(UnitClassLibrary.Moment,UnitClassLibrary.Moment)">
            <summary>less than or equal to</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Moment.op_GreaterThanOrEqual(UnitClassLibrary.Moment,UnitClassLibrary.Moment)">
            <summary>greater than or equal to</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Moment.GetHashCode">
            <summary>This override determines how this object is inserted into hashtables.</summary>
            <returns>same hashcode as any double would</returns>
        </member>
        <member name="M:UnitClassLibrary.Moment.ToString">
            <summary>The value and unit in terms of what the object was created with. </summary>
            <returns>Should never return anything</returns>
        </member>
        <member name="M:UnitClassLibrary.Moment.Equals(System.Object)">
            <summary>calls the Dimension only Equals method</summary>
        </member>
        <member name="M:UnitClassLibrary.Moment.Equals(UnitClassLibrary.Moment)">
            <summary>Compares using the function specified by strategy</summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Moment.ToString(UnitClassLibrary.MomentType)">
            <summary>prints the value and unit type converted to</summary>
            <param name="momentType"></param>
        </member>
        <member name="M:UnitClassLibrary.Moment.Negate">
            <summary>Creates a new object that is the negative of this</summary><returns>new object with value equivalent to result</returns>
        </member>
        <member name="M:UnitClassLibrary.Moment.AbsoluteValue">
            <summary>Creates a new object that is the absolute value of this</summary><returns>new object with value equivalent to result</returns>
        </member>
        <member name="M:UnitClassLibrary.Moment.RaiseToPower(System.Double)">
            <summary> multiplies itself a given number of times</summary><returns>new object with value equivalent to result</returns>
        </member>
        <member name="M:UnitClassLibrary.Moment.MakeMomentWithNewtonsMillimeters(System.Double)">
            <summary>Generator method that constructs Moment with assumption that the passed value is in NewtonsMillimeters</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Moment.MakeMomentWithNewtonsCentimeters(System.Double)">
            <summary>Generator method that constructs Moment with assumption that the passed value is in NewtonsCentimeters</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Moment.MakeMomentWithNewtonsMeters(System.Double)">
            <summary>Generator method that constructs Moment with assumption that the passed value is in NewtonsMeters</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Moment.MakeMomentWithNewtonsKilometers(System.Double)">
            <summary>Generator method that constructs Moment with assumption that the passed value is in NewtonsKilometers</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Moment.MakeMomentWithNewtonsInches(System.Double)">
            <summary>Generator method that constructs Moment with assumption that the passed value is in NewtonsInches</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Moment.MakeMomentWithNewtonsFeet(System.Double)">
            <summary>Generator method that constructs Moment with assumption that the passed value is in NewtonsFeet</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Moment.MakeMomentWithNewtonsYards(System.Double)">
            <summary>Generator method that constructs Moment with assumption that the passed value is in NewtonsYards</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Moment.MakeMomentWithNewtonsMiles(System.Double)">
            <summary>Generator method that constructs Moment with assumption that the passed value is in NewtonsMiles</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Moment.MakeMomentWithPoundsMillimeters(System.Double)">
            <summary>Generator method that constructs Moment with assumption that the passed value is in PoundsMillimeters</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Moment.MakeMomentWithPoundsCentimeters(System.Double)">
            <summary>Generator method that constructs Moment with assumption that the passed value is in PoundsCentimeters</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Moment.MakeMomentWithPoundsMeters(System.Double)">
            <summary>Generator method that constructs Moment with assumption that the passed value is in PoundsMeters</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Moment.MakeMomentWithPoundsKilometers(System.Double)">
            <summary>Generator method that constructs Moment with assumption that the passed value is in PoundsKilometers</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Moment.MakeMomentWithPoundsInches(System.Double)">
            <summary>Generator method that constructs Moment with assumption that the passed value is in PoundsInches</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Moment.MakeMomentWithPoundsFeet(System.Double)">
            <summary>Generator method that constructs Moment with assumption that the passed value is in PoundsFeet</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Moment.MakeMomentWithPoundsYards(System.Double)">
            <summary>Generator method that constructs Moment with assumption that the passed value is in PoundsYards</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Moment.MakeMomentWithPoundsMiles(System.Double)">
            <summary>Generator method that constructs Moment with assumption that the passed value is in PoundsMiles</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Moment.MakeMomentWithKipsMillimeters(System.Double)">
            <summary>Generator method that constructs Moment with assumption that the passed value is in KipsMillimeters</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Moment.MakeMomentWithKipsCentimeters(System.Double)">
            <summary>Generator method that constructs Moment with assumption that the passed value is in KipsCentimeters</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Moment.MakeMomentWithKipsMeters(System.Double)">
            <summary>Generator method that constructs Moment with assumption that the passed value is in KipsMeters</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Moment.MakeMomentWithKipsKilometers(System.Double)">
            <summary>Generator method that constructs Moment with assumption that the passed value is in KipsKilometers</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Moment.MakeMomentWithKipsInches(System.Double)">
            <summary>Generator method that constructs Moment with assumption that the passed value is in KipsInches</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Moment.MakeMomentWithKipsFeet(System.Double)">
            <summary>Generator method that constructs Moment with assumption that the passed value is in KipsFeet</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Moment.MakeMomentWithKipsYards(System.Double)">
            <summary>Generator method that constructs Moment with assumption that the passed value is in KipsYards</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Moment.MakeMomentWithKipsMiles(System.Double)">
            <summary>Generator method that constructs Moment with assumption that the passed value is in KipsMiles</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="T:UnitClassLibrary.MomentType">
            <summary> Enum for specifying the type of unit a Moment is.</summary>
        </member>
        <member name="T:UnitClassLibrary.MomentEqualityStrategy">
            <summary>delegate that defines the form of</summary>
            <param name="moment1"></param>
            <param name="moment2"></param>
            <returns></returns>
        </member>
        <member name="T:UnitClassLibrary.MomentDeviationDefaults">
            <summary> Default deviations allowed when comparing Moment objects </summary>
        </member>
        <member name="P:UnitClassLibrary.MomentDeviationDefaults.AcceptedEqualityDeviationDistance">
            <summary> When comparing two moment and deviation is allowed to be within a specific constant. This is that default constant </summary>
        </member>
        <member name="P:UnitClassLibrary.MomentDeviationDefaults.MomentAcceptedEqualityDeviationDistancePercentage">
            <summary> When comparing two moment and deviation is allowed to be within a percentage of the firstMoment. This is that percentage </summary>
        </member>
        <member name="T:UnitClassLibrary.MomentEqualityStrategyImplementations">
            <summary> functions that can be used for a moment object's equals functions </summary>
        </member>
        <member name="M:UnitClassLibrary.MomentEqualityStrategyImplementations.DefaultPercentageEquality(UnitClassLibrary.Moment,UnitClassLibrary.Moment)">
            <summary> Moments are equal if they differ by less than a percentage of the first Moment </summary>
            <param name="moment1">first moment being compared</param>
            <param name="moment2">second moment being compared</param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.MomentEqualityStrategyImplementations.DefaultConstantEquality(UnitClassLibrary.Moment,UnitClassLibrary.Moment)">
            <summary> Moments are equal if there values are within the passed deviation constant. If they are not within the constant </summary>
            <param name="moment1">first moment being compared</param>
            <param name="moment2">second moment being compared</param>
            <returns></returns>
        </member>
        <member name="T:UnitClassLibrary.Power">
            <summary>
            Distance class for units of power
            </summary>
        </member>
        <member name="M:UnitClassLibrary.Power.GetHashCode">
            <summary>
            This override determines how this object is inserted into hashtables.
            </summary>
            <returns>same hashcode as any double would</returns>
        </member>
        <member name="M:UnitClassLibrary.Power.op_Addition(UnitClassLibrary.Power,UnitClassLibrary.Power)">
            <summary>
            adds two powers
            </summary>
            <param name="p1">power one</param>
            <param name="p2">power two</param>
            <returns>the sum of the two forces</returns>
        </member>
        <member name="M:UnitClassLibrary.Power.op_Subtraction(UnitClassLibrary.Power,UnitClassLibrary.Power)">
            <summary>
            subtracts two powers
            </summary>
            <param name="p1">power one</param>
            <param name="p2">power two</param>
            <returns>the sum of the two forces</returns>
        </member>
        <member name="M:UnitClassLibrary.Power.op_Equality(UnitClassLibrary.Power,UnitClassLibrary.Power)">
            <summary>
            Not a perfect equality operator, is only accurate up to Constants.AcceptedEqualityDeviationConstant 
            </summary>
        </member>
        <member name="M:UnitClassLibrary.Power.op_Inequality(UnitClassLibrary.Power,UnitClassLibrary.Power)">
            <summary>
            Not a perfect inequality operator, is only accurate up to Constants.AcceptedEqualityDeviationConstant 
            </summary>
        </member>
        <member name="M:UnitClassLibrary.Power.op_GreaterThan(UnitClassLibrary.Power,UnitClassLibrary.Power)">
            <summary>
            Compare p1 and p2 in units of p1
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Power.op_LessThan(UnitClassLibrary.Power,UnitClassLibrary.Power)">
            <summary>
            Compare p1 and p2 in units of p1
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Power.Equals(System.Object)">
            <summary>
            value comparison, checks whether the two are equal within the accepted equality deviation specified in Constants
            </summary>
        </member>
        <member name="M:UnitClassLibrary.Power.EqualsWithinPassedAcceptedDeviation(System.Object,UnitClassLibrary.Power)">
            <summary>
            value comparison, checks whether the two are equal within a passed accepted equality deviation
            </summary>
        </member>
        <member name="P:UnitClassLibrary.Power.Watt">
            <summary>
            returns power as watts
            </summary>
        </member>
        <member name="P:UnitClassLibrary.Power.Horsepower">
            <summary>
            Returns power as horsepower
            </summary>
        </member>
        <member name="P:UnitClassLibrary.Power.FootPoundsPerSecond">
            <summary>
            Returns power as foot pounds / minute
            </summary>
        </member>
        <member name="P:UnitClassLibrary.Power.ErgsPerSecond">
            <summary>
            Returns power as ergs / second
            </summary>
        </member>
        <member name="M:UnitClassLibrary.Speed.#ctor(UnitClassLibrary.SpeedEqualityStrategy)">
            <summary> Zero Constructor </summary>
        </member>
        <member name="M:UnitClassLibrary.Speed.#ctor(UnitClassLibrary.Distance,UnitClassLibrary.Time,UnitClassLibrary.SpeedEqualityStrategy)">
            <summary> constructor that creates moment based on the passed units </summary>
        </member>
        <member name="M:UnitClassLibrary.Speed.#ctor(UnitClassLibrary.SpeedType,System.Double,UnitClassLibrary.SpeedEqualityStrategy)">
            <summary> Copy constructor (new unit with same fields as the passed) </summary>
        </member>
        <member name="M:UnitClassLibrary.Speed.EqualsWithinDeviationConstant(UnitClassLibrary.Speed,UnitClassLibrary.Speed)">
            <summary> value comparison, checks whether the two are equal within a passed accepted equality deviation </summary>
        </member>
        <member name="M:UnitClassLibrary.Speed.EqualsWithinDeviationPercentage(UnitClassLibrary.Speed,UnitClassLibrary.Speed)">
            <summary> value comparison, checks whether the two are equal within a passed accepted equality percentage </summary>
        </member>
        <member name="M:UnitClassLibrary.Speed.EqualsWithinDistanceEqualityStrategy(UnitClassLibrary.Speed,UnitClassLibrary.SpeedEqualityStrategy)">
            <summary> value comparison, checks whether the two are equal within a passed accepted equality percentage </summary>
        </member>
        <member name="M:UnitClassLibrary.Speed.CompareTo(UnitClassLibrary.Speed)">
            <summary> This implements the IComparable (Speed) interface and allows Speeds to be sorted and such </summary>
        </member>
        <member name="M:UnitClassLibrary.Speed.CompareTo(System.Object)">
            <summary> This implements the IComparable (Speed) interface and allows Speeds to be sorted and such </summary>
        </member>
        <member name="M:UnitClassLibrary.Speed.op_ExclusiveOr(UnitClassLibrary.Speed,System.Double)">
            <summary>Raise to power operator</summary>
            <param name="o1"></param>
            <param name="power"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.op_Addition(UnitClassLibrary.Speed,UnitClassLibrary.Speed)">
            <summary>Returns new unit with sum of two passed units</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.op_Subtraction(UnitClassLibrary.Speed,UnitClassLibrary.Speed)">
            <summary>Returns new unit with difference of two passed units</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.op_Division(UnitClassLibrary.Speed,UnitClassLibrary.Speed)">
            <summary>ratio between differences</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.op_Multiply(UnitClassLibrary.Speed,System.Double)">
            <summary>scalar multiplication</summary>
            <param name="o1"></param>
            <param name="multiplier"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.op_Multiply(System.Double,UnitClassLibrary.Speed)">
            <summary>scalar multiplication</summary>
            <param name="o1"></param>
            <param name="multiplier"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.op_Division(UnitClassLibrary.Speed,System.Double)">
            <summary>scalar division</summary>
            <param name="o1"></param>
            <param name="divisor"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.op_Inequality(UnitClassLibrary.Speed,UnitClassLibrary.Speed)">
            <summary>Not a perfect inequality operator, is only accurate up to Constants.AcceptedEqualityDeviationConstant </summary>
        </member>
        <member name="M:UnitClassLibrary.Speed.op_Equality(UnitClassLibrary.Speed,UnitClassLibrary.Speed)">
            <summary>Not a perfect equality operator, is only accurate up to Constants.AcceptedEqualityDeviationConstant </summary>
        </member>
        <member name="M:UnitClassLibrary.Speed.op_GreaterThan(UnitClassLibrary.Speed,UnitClassLibrary.Speed)">
            <summary>greater than</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.op_LessThan(UnitClassLibrary.Speed,UnitClassLibrary.Speed)">
            <summary>less than</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.op_LessThanOrEqual(UnitClassLibrary.Speed,UnitClassLibrary.Speed)">
            <summary>less than or equal to</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.op_GreaterThanOrEqual(UnitClassLibrary.Speed,UnitClassLibrary.Speed)">
            <summary>greater than or equal to</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.GetHashCode">
            <summary>This override determines how this object is inserted into hashtables.</summary>
            <returns>same hashcode as any double would</returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.ToString">
            <summary>The value and unit in terms of what the object was created with. </summary>
            <returns>Should never return anything</returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.Equals(System.Object)">
            <summary>calls the Dimension only Equals method</summary>
        </member>
        <member name="M:UnitClassLibrary.Speed.Equals(UnitClassLibrary.Speed)">
            <summary>Compares using the function specified by strategy</summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.ToString(UnitClassLibrary.SpeedType)">
            <summary>prints the value and unit type converted to</summary>
            <param name="speedType"></param>
        </member>
        <member name="M:UnitClassLibrary.Speed.Negate">
            <summary>Creates a new object that is the negative of this</summary><returns>new object with value equivalent to result</returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.AbsoluteValue">
            <summary>Creates a new object that is the absolute value of this</summary><returns>new object with value equivalent to result</returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.RaiseToPower(System.Double)">
            <summary> multiplies itself a given number of times</summary><returns>new object with value equivalent to result</returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithMillimetersPerNanoseconds(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in MillimetersPerNanoseconds</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithMillimetersPerMicroseconds(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in MillimetersPerMicroseconds</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithMillimetersPerMilliseconds(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in MillimetersPerMilliseconds</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithMillimetersPerSeconds(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in MillimetersPerSeconds</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithMillimetersPerMinutes(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in MillimetersPerMinutes</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithMillimetersPerHours(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in MillimetersPerHours</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithMillimetersPerDays(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in MillimetersPerDays</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithMillimetersPerWeeks(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in MillimetersPerWeeks</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithMillimetersPerMonths(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in MillimetersPerMonths</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithMillimetersPerYears(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in MillimetersPerYears</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithMillimetersPerDecades(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in MillimetersPerDecades</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithMillimetersPerCenturies(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in MillimetersPerCenturies</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithCentimetersPerNanoseconds(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in CentimetersPerNanoseconds</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithCentimetersPerMicroseconds(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in CentimetersPerMicroseconds</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithCentimetersPerMilliseconds(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in CentimetersPerMilliseconds</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithCentimetersPerSeconds(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in CentimetersPerSeconds</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithCentimetersPerMinutes(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in CentimetersPerMinutes</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithCentimetersPerHours(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in CentimetersPerHours</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithCentimetersPerDays(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in CentimetersPerDays</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithCentimetersPerWeeks(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in CentimetersPerWeeks</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithCentimetersPerMonths(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in CentimetersPerMonths</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithCentimetersPerYears(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in CentimetersPerYears</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithCentimetersPerDecades(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in CentimetersPerDecades</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithCentimetersPerCenturies(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in CentimetersPerCenturies</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithMetersPerNanoseconds(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in MetersPerNanoseconds</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithMetersPerMicroseconds(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in MetersPerMicroseconds</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithMetersPerMilliseconds(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in MetersPerMilliseconds</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithMetersPerSeconds(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in MetersPerSeconds</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithMetersPerMinutes(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in MetersPerMinutes</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithMetersPerHours(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in MetersPerHours</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithMetersPerDays(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in MetersPerDays</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithMetersPerWeeks(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in MetersPerWeeks</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithMetersPerMonths(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in MetersPerMonths</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithMetersPerYears(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in MetersPerYears</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithMetersPerDecades(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in MetersPerDecades</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithMetersPerCenturies(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in MetersPerCenturies</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithKilometersPerNanoseconds(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in KilometersPerNanoseconds</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithKilometersPerMicroseconds(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in KilometersPerMicroseconds</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithKilometersPerMilliseconds(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in KilometersPerMilliseconds</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithKilometersPerSeconds(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in KilometersPerSeconds</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithKilometersPerMinutes(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in KilometersPerMinutes</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithKilometersPerHours(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in KilometersPerHours</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithKilometersPerDays(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in KilometersPerDays</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithKilometersPerWeeks(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in KilometersPerWeeks</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithKilometersPerMonths(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in KilometersPerMonths</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithKilometersPerYears(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in KilometersPerYears</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithKilometersPerDecades(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in KilometersPerDecades</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithKilometersPerCenturies(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in KilometersPerCenturies</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithInchesPerNanoseconds(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in InchesPerNanoseconds</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithInchesPerMicroseconds(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in InchesPerMicroseconds</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithInchesPerMilliseconds(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in InchesPerMilliseconds</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithInchesPerSeconds(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in InchesPerSeconds</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithInchesPerMinutes(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in InchesPerMinutes</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithInchesPerHours(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in InchesPerHours</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithInchesPerDays(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in InchesPerDays</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithInchesPerWeeks(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in InchesPerWeeks</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithInchesPerMonths(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in InchesPerMonths</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithInchesPerYears(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in InchesPerYears</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithInchesPerDecades(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in InchesPerDecades</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithInchesPerCenturies(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in InchesPerCenturies</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithFeetPerNanoseconds(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in FeetPerNanoseconds</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithFeetPerMicroseconds(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in FeetPerMicroseconds</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithFeetPerMilliseconds(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in FeetPerMilliseconds</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithFeetPerSeconds(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in FeetPerSeconds</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithFeetPerMinutes(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in FeetPerMinutes</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithFeetPerHours(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in FeetPerHours</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithFeetPerDays(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in FeetPerDays</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithFeetPerWeeks(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in FeetPerWeeks</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithFeetPerMonths(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in FeetPerMonths</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithFeetPerYears(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in FeetPerYears</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithFeetPerDecades(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in FeetPerDecades</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithFeetPerCenturies(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in FeetPerCenturies</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithYardsPerNanoseconds(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in YardsPerNanoseconds</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithYardsPerMicroseconds(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in YardsPerMicroseconds</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithYardsPerMilliseconds(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in YardsPerMilliseconds</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithYardsPerSeconds(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in YardsPerSeconds</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithYardsPerMinutes(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in YardsPerMinutes</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithYardsPerHours(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in YardsPerHours</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithYardsPerDays(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in YardsPerDays</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithYardsPerWeeks(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in YardsPerWeeks</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithYardsPerMonths(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in YardsPerMonths</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithYardsPerYears(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in YardsPerYears</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithYardsPerDecades(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in YardsPerDecades</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithYardsPerCenturies(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in YardsPerCenturies</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithMilesPerNanoseconds(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in MilesPerNanoseconds</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithMilesPerMicroseconds(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in MilesPerMicroseconds</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithMilesPerMilliseconds(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in MilesPerMilliseconds</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithMilesPerSeconds(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in MilesPerSeconds</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithMilesPerMinutes(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in MilesPerMinutes</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithMilesPerHours(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in MilesPerHours</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithMilesPerDays(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in MilesPerDays</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithMilesPerWeeks(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in MilesPerWeeks</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithMilesPerMonths(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in MilesPerMonths</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithMilesPerYears(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in MilesPerYears</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithMilesPerDecades(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in MilesPerDecades</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Speed.MakeSpeedWithMilesPerCenturies(System.Double)">
            <summary>Generator method that constructs Speed with assumption that the passed value is in MilesPerCenturies</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="T:UnitClassLibrary.SpeedType">
            <summary> Enum for specifying the type of unit a Speed is.</summary>
        </member>
        <member name="T:UnitClassLibrary.SpeedEqualityStrategy">
            <summary>delegate that defines the form of</summary>
            <param name="speed1"></param>
            <param name="speed2"></param>
            <returns></returns>
        </member>
        <member name="T:UnitClassLibrary.SpeedDeviationDefaults">
            <summary> Default deviations allowed when comparing Speed objects </summary>
        </member>
        <member name="P:UnitClassLibrary.SpeedDeviationDefaults.AcceptedEqualityDeviationDistance">
            <summary> When comparing two speed and deviation is allowed to be within a specific constant. This is that default constant </summary>
        </member>
        <member name="P:UnitClassLibrary.SpeedDeviationDefaults.SpeedAcceptedEqualityDeviationDistancePercentage">
            <summary> When comparing two speed and deviation is allowed to be within a percentage of the firstSpeed. This is that percentage </summary>
        </member>
        <member name="T:UnitClassLibrary.SpeedEqualityStrategyImplementations">
            <summary> functions that can be used for a speed object's equals functions </summary>
        </member>
        <member name="M:UnitClassLibrary.SpeedEqualityStrategyImplementations.DefaultPercentageEquality(UnitClassLibrary.Speed,UnitClassLibrary.Speed)">
            <summary> Speeds are equal if they differ by less than a percentage of the first Speed </summary>
            <param name="speed1">first speed being compared</param>
            <param name="speed2">second speed being compared</param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.SpeedEqualityStrategyImplementations.DefaultConstantEquality(UnitClassLibrary.Speed,UnitClassLibrary.Speed)">
            <summary> Speeds are equal if there values are within the passed deviation constant. If they are not within the constant </summary>
            <param name="speed1">first speed being compared</param>
            <param name="speed2">second speed being compared</param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Stiffness.#ctor(UnitClassLibrary.StiffnessEqualityStrategy)">
            <summary> Zero Constructor </summary>
        </member>
        <member name="M:UnitClassLibrary.Stiffness.#ctor(UnitClassLibrary.Force,UnitClassLibrary.Distance,UnitClassLibrary.StiffnessEqualityStrategy)">
            <summary> constructor that creates moment based on the passed units </summary>
        </member>
        <member name="M:UnitClassLibrary.Stiffness.#ctor(UnitClassLibrary.StiffnessType,System.Double)">
            <summary> Copy constructor (new unit with same fields as the passed) </summary>
        </member>
        <member name="M:UnitClassLibrary.Stiffness.EqualsWithinDeviationConstant(UnitClassLibrary.Stiffness,UnitClassLibrary.Stiffness)">
            <summary> value comparison, checks whether the two are equal within a passed accepted equality deviation </summary>
        </member>
        <member name="M:UnitClassLibrary.Stiffness.EqualsWithinDeviationPercentage(UnitClassLibrary.Stiffness,UnitClassLibrary.Stiffness)">
            <summary> value comparison, checks whether the two are equal within a passed accepted equality percentage </summary>
        </member>
        <member name="M:UnitClassLibrary.Stiffness.EqualsWithinDistanceEqualityStrategy(UnitClassLibrary.Stiffness,UnitClassLibrary.StiffnessEqualityStrategy)">
            <summary> value comparison, checks whether the two are equal within a passed accepted equality percentage </summary>
        </member>
        <member name="M:UnitClassLibrary.Stiffness.CompareTo(UnitClassLibrary.Stiffness)">
            <summary> This implements the IComparable (Stiffness) interface and allows Stiffnesss to be sorted and such </summary>
        </member>
        <member name="M:UnitClassLibrary.Stiffness.CompareTo(System.Object)">
            <summary> This implements the IComparable (Stiffness) interface and allows Stiffnesss to be sorted and such </summary>
        </member>
        <member name="M:UnitClassLibrary.Stiffness.op_ExclusiveOr(UnitClassLibrary.Stiffness,System.Double)">
            <summary>Raise to power operator</summary>
            <param name="o1"></param>
            <param name="power"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Stiffness.op_Addition(UnitClassLibrary.Stiffness,UnitClassLibrary.Stiffness)">
            <summary>Returns new unit with sum of two passed units</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Stiffness.op_Subtraction(UnitClassLibrary.Stiffness,UnitClassLibrary.Stiffness)">
            <summary>Returns new unit with difference of two passed units</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Stiffness.op_Division(UnitClassLibrary.Stiffness,UnitClassLibrary.Stiffness)">
            <summary>ratio between differences</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Stiffness.op_Multiply(UnitClassLibrary.Stiffness,System.Double)">
            <summary>scalar multiplication</summary>
            <param name="o1"></param>
            <param name="multiplier"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Stiffness.op_Multiply(System.Double,UnitClassLibrary.Stiffness)">
            <summary>scalar multiplication</summary>
            <param name="o1"></param>
            <param name="multiplier"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Stiffness.op_Division(UnitClassLibrary.Stiffness,System.Double)">
            <summary>scalar division</summary>
            <param name="o1"></param>
            <param name="divisor"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Stiffness.op_Inequality(UnitClassLibrary.Stiffness,UnitClassLibrary.Stiffness)">
            <summary>Not a perfect inequality operator, is only accurate up to Constants.AcceptedEqualityDeviationConstant </summary>
        </member>
        <member name="M:UnitClassLibrary.Stiffness.op_Equality(UnitClassLibrary.Stiffness,UnitClassLibrary.Stiffness)">
            <summary>Not a perfect equality operator, is only accurate up to Constants.AcceptedEqualityDeviationConstant </summary>
        </member>
        <member name="M:UnitClassLibrary.Stiffness.op_GreaterThan(UnitClassLibrary.Stiffness,UnitClassLibrary.Stiffness)">
            <summary>greater than</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Stiffness.op_LessThan(UnitClassLibrary.Stiffness,UnitClassLibrary.Stiffness)">
            <summary>less than</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Stiffness.op_LessThanOrEqual(UnitClassLibrary.Stiffness,UnitClassLibrary.Stiffness)">
            <summary>less than or equal to</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Stiffness.op_GreaterThanOrEqual(UnitClassLibrary.Stiffness,UnitClassLibrary.Stiffness)">
            <summary>greater than or equal to</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Stiffness.GetHashCode">
            <summary>This override determines how this object is inserted into hashtables.</summary>
            <returns>same hashcode as any double would</returns>
        </member>
        <member name="M:UnitClassLibrary.Stiffness.ToString">
            <summary>The value and unit in terms of what the object was created with. </summary>
            <returns>Should never return anything</returns>
        </member>
        <member name="M:UnitClassLibrary.Stiffness.Equals(System.Object)">
            <summary>calls the Dimension only Equals method</summary>
        </member>
        <member name="M:UnitClassLibrary.Stiffness.Equals(UnitClassLibrary.Stiffness)">
            <summary>Compares using the function specified by strategy</summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Stiffness.ToString(UnitClassLibrary.StiffnessType)">
            <summary>prints the value and unit type converted to</summary>
            <param name="stiffnessType"></param>
        </member>
        <member name="M:UnitClassLibrary.Stiffness.Negate">
            <summary>Creates a new object that is the negative of this</summary><returns>new object with value equivalent to result</returns>
        </member>
        <member name="M:UnitClassLibrary.Stiffness.AbsoluteValue">
            <summary>Creates a new object that is the absolute value of this</summary><returns>new object with value equivalent to result</returns>
        </member>
        <member name="M:UnitClassLibrary.Stiffness.RaiseToPower(System.Double)">
            <summary> multiplies itself a given number of times</summary><returns>new object with value equivalent to result</returns>
        </member>
        <member name="M:UnitClassLibrary.Stiffness.MakeStiffnessWithNewtonsPerMillimeters(System.Double)">
            <summary>Generator method that constructs Stiffness with assumption that the passed value is in NewtonsPerMillimeters</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Stiffness.MakeStiffnessWithNewtonsPerCentimeters(System.Double)">
            <summary>Generator method that constructs Stiffness with assumption that the passed value is in NewtonsPerCentimeters</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Stiffness.MakeStiffnessWithNewtonsPerMeters(System.Double)">
            <summary>Generator method that constructs Stiffness with assumption that the passed value is in NewtonsPerMeters</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Stiffness.MakeStiffnessWithNewtonsPerKilometers(System.Double)">
            <summary>Generator method that constructs Stiffness with assumption that the passed value is in NewtonsPerKilometers</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Stiffness.MakeStiffnessWithNewtonsPerInches(System.Double)">
            <summary>Generator method that constructs Stiffness with assumption that the passed value is in NewtonsPerInches</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Stiffness.MakeStiffnessWithNewtonsPerFeet(System.Double)">
            <summary>Generator method that constructs Stiffness with assumption that the passed value is in NewtonsPerFeet</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Stiffness.MakeStiffnessWithNewtonsPerYards(System.Double)">
            <summary>Generator method that constructs Stiffness with assumption that the passed value is in NewtonsPerYards</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Stiffness.MakeStiffnessWithNewtonsPerMiles(System.Double)">
            <summary>Generator method that constructs Stiffness with assumption that the passed value is in NewtonsPerMiles</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Stiffness.MakeStiffnessWithPoundsPerMillimeters(System.Double)">
            <summary>Generator method that constructs Stiffness with assumption that the passed value is in PoundsPerMillimeters</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Stiffness.MakeStiffnessWithPoundsPerCentimeters(System.Double)">
            <summary>Generator method that constructs Stiffness with assumption that the passed value is in PoundsPerCentimeters</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Stiffness.MakeStiffnessWithPoundsPerMeters(System.Double)">
            <summary>Generator method that constructs Stiffness with assumption that the passed value is in PoundsPerMeters</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Stiffness.MakeStiffnessWithPoundsPerKilometers(System.Double)">
            <summary>Generator method that constructs Stiffness with assumption that the passed value is in PoundsPerKilometers</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Stiffness.MakeStiffnessWithPoundsPerInches(System.Double)">
            <summary>Generator method that constructs Stiffness with assumption that the passed value is in PoundsPerInches</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Stiffness.MakeStiffnessWithPoundsPerFeet(System.Double)">
            <summary>Generator method that constructs Stiffness with assumption that the passed value is in PoundsPerFeet</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Stiffness.MakeStiffnessWithPoundsPerYards(System.Double)">
            <summary>Generator method that constructs Stiffness with assumption that the passed value is in PoundsPerYards</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Stiffness.MakeStiffnessWithPoundsPerMiles(System.Double)">
            <summary>Generator method that constructs Stiffness with assumption that the passed value is in PoundsPerMiles</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Stiffness.MakeStiffnessWithKipsPerMillimeters(System.Double)">
            <summary>Generator method that constructs Stiffness with assumption that the passed value is in KipsPerMillimeters</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Stiffness.MakeStiffnessWithKipsPerCentimeters(System.Double)">
            <summary>Generator method that constructs Stiffness with assumption that the passed value is in KipsPerCentimeters</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Stiffness.MakeStiffnessWithKipsPerMeters(System.Double)">
            <summary>Generator method that constructs Stiffness with assumption that the passed value is in KipsPerMeters</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Stiffness.MakeStiffnessWithKipsPerKilometers(System.Double)">
            <summary>Generator method that constructs Stiffness with assumption that the passed value is in KipsPerKilometers</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Stiffness.MakeStiffnessWithKipsPerInches(System.Double)">
            <summary>Generator method that constructs Stiffness with assumption that the passed value is in KipsPerInches</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Stiffness.MakeStiffnessWithKipsPerFeet(System.Double)">
            <summary>Generator method that constructs Stiffness with assumption that the passed value is in KipsPerFeet</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Stiffness.MakeStiffnessWithKipsPerYards(System.Double)">
            <summary>Generator method that constructs Stiffness with assumption that the passed value is in KipsPerYards</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Stiffness.MakeStiffnessWithKipsPerMiles(System.Double)">
            <summary>Generator method that constructs Stiffness with assumption that the passed value is in KipsPerMiles</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="T:UnitClassLibrary.StiffnessType">
            <summary> Enum for specifying the type of unit a Stiffness is.</summary>
        </member>
        <member name="T:UnitClassLibrary.StiffnessEqualityStrategy">
            <summary>delegate that defines the form of</summary>
            <param name="stiffness1"></param>
            <param name="stiffness2"></param>
            <returns></returns>
        </member>
        <member name="T:UnitClassLibrary.StiffnessDeviationDefaults">
            <summary> Default deviations allowed when comparing Stiffness objects </summary>
        </member>
        <member name="P:UnitClassLibrary.StiffnessDeviationDefaults.AcceptedEqualityDeviationDistance">
            <summary> When comparing two stiffness and deviation is allowed to be within a specific constant. This is that default constant </summary>
        </member>
        <member name="P:UnitClassLibrary.StiffnessDeviationDefaults.StiffnessAcceptedEqualityDeviationDistancePercentage">
            <summary> When comparing two stiffness and deviation is allowed to be within a percentage of the firstStiffness. This is that percentage </summary>
        </member>
        <member name="T:UnitClassLibrary.StiffnessEqualityStrategyImplementations">
            <summary> functions that can be used for a stiffness object's equals functions </summary>
        </member>
        <member name="M:UnitClassLibrary.StiffnessEqualityStrategyImplementations.DefaultPercentageEquality(UnitClassLibrary.Stiffness,UnitClassLibrary.Stiffness)">
            <summary> Stiffnesss are equal if they differ by less than a percentage of the first Stiffness </summary>
            <param name="stiffness1">first stiffness being compared</param>
            <param name="stiffness2">second stiffness being compared</param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.StiffnessEqualityStrategyImplementations.DefaultConstantEquality(UnitClassLibrary.Stiffness,UnitClassLibrary.Stiffness)">
            <summary> Stiffnesss are equal if there values are within the passed deviation constant. If they are not within the constant </summary>
            <param name="stiffness1">first stiffness being compared</param>
            <param name="stiffness2">second stiffness being compared</param>
            <returns></returns>
        </member>
        <member name="T:UnitClassLibrary.Stress">
            <summary>
            Force applied to an area
            </summary>
        </member>
        <member name="M:UnitClassLibrary.Stress.#ctor">
            <summary>
            Zero Constructor
            </summary>
        </member>
        <member name="M:UnitClassLibrary.Stress.#ctor(UnitClassLibrary.Force,UnitClassLibrary.Area)">
            <summary>
            Standard Constructor
            </summary>
            <param name="passedArea"></param>
            <param name="passedForce"></param>
        </member>
        <member name="M:UnitClassLibrary.Stress.#ctor(UnitClassLibrary.StressType,System.Double)">
            <summary>
            Create a stress object from a composite unit; the value is arbitrarily distributed among the component units.
            </summary>
            <param name="passedStressType"></param>
            <param name="passedValue"></param>
        </member>
        <member name="M:UnitClassLibrary.Stress.op_Equality(UnitClassLibrary.Stress,UnitClassLibrary.Stress)">
            <summary>
            Not a perfect equality operator, is only accurate up to the Constants.AcceptedEqualityDeviationConstant 
            </summary>
        </member>
        <member name="M:UnitClassLibrary.Stress.op_Inequality(UnitClassLibrary.Stress,UnitClassLibrary.Stress)">
            <summary>
            Not a perfect inequality operator, is only accurate up to Constants.AcceptedEqualityDeviationConstant 
            </summary>
        </member>
        <member name="M:UnitClassLibrary.Stress.GetHashCode">
            <summary>
            This override determines how this object is inserted into hashtables.
            </summary>
            <returns>same hashcode as any double would</returns>
        </member>
        <member name="M:UnitClassLibrary.Stress.Equals(System.Object)">
            <summary>
            does the same thing as == if the passed in object is a Stress
            </summary>
        </member>
        <member name="M:UnitClassLibrary.Stress.CompareTo(UnitClassLibrary.Stress)">
            <summary>
            This implements the IComparable interface and allows Stresss to be sorted and such
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Temperature.#ctor(UnitClassLibrary.TemperatureEqualityStrategy)">
            <summary> Zero Constructor </summary>
        </member>
        <member name="M:UnitClassLibrary.Temperature.#ctor(UnitClassLibrary.TemperatureType,System.Double,UnitClassLibrary.TemperatureEqualityStrategy)">
            <summary> Accepts standard types for input. </summary>
        </member>
        <member name="M:UnitClassLibrary.Temperature.#ctor(UnitClassLibrary.Temperature)">
            <summary> Copy constructor (new unit with same fields as the passed) </summary>
        </member>
        <member name="M:UnitClassLibrary.Temperature.ConvertTemperature(UnitClassLibrary.TemperatureType,System.Double,UnitClassLibrary.TemperatureType)">
            <summary>Converts one unit of Temperature to another
            Conversion source: http://en.wikipedia.org/wiki/Conversion_of_units_of_temperature
            </summary>
            <param name="typeConvertingTo">input unit type</param>
            <param name="passedValue"></param>
            <param name="typeConvertingFrom">desired output unit type</param>
            <returns>passedValue in desired units</returns>
        </member>
        <member name="M:UnitClassLibrary.Temperature.EqualsWithinDeviationConstant(UnitClassLibrary.Temperature,UnitClassLibrary.Temperature)">
            <summary> value comparison, checks whether the two are equal within a passed accepted equality deviation </summary>
        </member>
        <member name="M:UnitClassLibrary.Temperature.EqualsWithinDeviationPercentage(UnitClassLibrary.Temperature,UnitClassLibrary.Temperature)">
            <summary> value comparison, checks whether the two are equal within a passed accepted equality percentage </summary>
        </member>
        <member name="M:UnitClassLibrary.Temperature.EqualsWithinDistanceEqualityStrategy(UnitClassLibrary.Temperature,UnitClassLibrary.TemperatureEqualityStrategy)">
            <summary> value comparison, checks whether the two are equal within a passed accepted equality percentage </summary>
        </member>
        <member name="M:UnitClassLibrary.Temperature.CompareTo(UnitClassLibrary.Temperature)">
            <summary> This implements the IComparable (Temperature) interface and allows Temperatures to be sorted and such </summary>
        </member>
        <member name="M:UnitClassLibrary.Temperature.CompareTo(System.Object)">
            <summary> This implements the IComparable (Temperature) interface and allows Temperatures to be sorted and such </summary>
        </member>
        <member name="M:UnitClassLibrary.Temperature.op_ExclusiveOr(UnitClassLibrary.Temperature,System.Double)">
            <summary>Raise to power operator</summary>
            <param name="o1"></param>
            <param name="power"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Temperature.op_Addition(UnitClassLibrary.Temperature,UnitClassLibrary.Temperature)">
            <summary>Returns new unit with sum of two passed units</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Temperature.op_Subtraction(UnitClassLibrary.Temperature,UnitClassLibrary.Temperature)">
            <summary>Returns new unit with difference of two passed units</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Temperature.op_Division(UnitClassLibrary.Temperature,UnitClassLibrary.Temperature)">
            <summary>ratio between differences</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Temperature.op_Multiply(UnitClassLibrary.Temperature,System.Double)">
            <summary>scalar multiplication</summary>
            <param name="o1"></param>
            <param name="multiplier"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Temperature.op_Multiply(System.Double,UnitClassLibrary.Temperature)">
            <summary>scalar multiplication</summary>
            <param name="o1"></param>
            <param name="multiplier"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Temperature.op_Division(UnitClassLibrary.Temperature,System.Double)">
            <summary>scalar division</summary>
            <param name="o1"></param>
            <param name="divisor"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Temperature.op_Inequality(UnitClassLibrary.Temperature,UnitClassLibrary.Temperature)">
            <summary>Not a perfect inequality operator, is only accurate up to Constants.AcceptedEqualityDeviationConstant </summary>
        </member>
        <member name="M:UnitClassLibrary.Temperature.op_Equality(UnitClassLibrary.Temperature,UnitClassLibrary.Temperature)">
            <summary>Not a perfect equality operator, is only accurate up to Constants.AcceptedEqualityDeviationConstant </summary>
        </member>
        <member name="M:UnitClassLibrary.Temperature.op_GreaterThan(UnitClassLibrary.Temperature,UnitClassLibrary.Temperature)">
            <summary>greater than</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Temperature.op_LessThan(UnitClassLibrary.Temperature,UnitClassLibrary.Temperature)">
            <summary>less than</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Temperature.op_LessThanOrEqual(UnitClassLibrary.Temperature,UnitClassLibrary.Temperature)">
            <summary>less than or equal to</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Temperature.op_GreaterThanOrEqual(UnitClassLibrary.Temperature,UnitClassLibrary.Temperature)">
            <summary>greater than or equal to</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Temperature.GetHashCode">
            <summary>This override determines how this object is inserted into hashtables.</summary>
            <returns>same hashcode as any double would</returns>
        </member>
        <member name="M:UnitClassLibrary.Temperature.ToString">
            <summary>The value and unit in terms of what the object was created with. </summary>
            <returns>Should never return anything</returns>
        </member>
        <member name="M:UnitClassLibrary.Temperature.Equals(System.Object)">
            <summary>calls the Dimension only Equals method</summary>
        </member>
        <member name="M:UnitClassLibrary.Temperature.Equals(UnitClassLibrary.Temperature)">
            <summary>Compares using the function specified by strategy</summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Temperature.ToString(UnitClassLibrary.TemperatureType)">
            <summary>prints the value and unit type converted to</summary>
            <param name="temperatureType"></param>
        </member>
        <member name="M:UnitClassLibrary.Temperature.Negate">
            <summary>Creates a new object that is the negative of this</summary><returns>new object with value equivalent to result</returns>
        </member>
        <member name="M:UnitClassLibrary.Temperature.AbsoluteValue">
            <summary>Creates a new object that is the absolute value of this</summary><returns>new object with value equivalent to result</returns>
        </member>
        <member name="M:UnitClassLibrary.Temperature.RaiseToPower(System.Double)">
            <summary> multiplies itself a given number of times</summary><returns>new object with value equivalent to result</returns>
        </member>
        <member name="M:UnitClassLibrary.Temperature.MakeTemperatureWithCelsiusDegrees(System.Double)">
            <summary>Generator method that constructs Temperature with assumption that the passed value is in CelsiusDegrees</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Temperature.MakeTemperatureWithFahrenheitDegrees(System.Double)">
            <summary>Generator method that constructs Temperature with assumption that the passed value is in FahrenheitDegrees</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Temperature.MakeTemperatureWithKelvinDegrees(System.Double)">
            <summary>Generator method that constructs Temperature with assumption that the passed value is in KelvinDegrees</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Temperature.MakeTemperatureWithRankineDegrees(System.Double)">
            <summary>Generator method that constructs Temperature with assumption that the passed value is in RankineDegrees</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Temperature.MakeTemperatureWithDelisleDegrees(System.Double)">
            <summary>Generator method that constructs Temperature with assumption that the passed value is in DelisleDegrees</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Temperature.MakeTemperatureWithReaumurDegrees(System.Double)">
            <summary>Generator method that constructs Temperature with assumption that the passed value is in ReaumurDegrees</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Temperature.MakeTemperatureWithRomerDegrees(System.Double)">
            <summary>Generator method that constructs Temperature with assumption that the passed value is in RomerDegrees</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="T:UnitClassLibrary.TemperatureType">
            <summary> Enum for specifying the type of unit a Temperature is.</summary>
        </member>
        <member name="T:UnitClassLibrary.TemperatureEqualityStrategy">
            <summary>delegate that defines the form of</summary>
            <param name="temperature1"></param>
            <param name="temperature2"></param>
            <returns></returns>
        </member>
        <member name="T:UnitClassLibrary.TemperatureDeviationDefaults">
            <summary> Default deviations allowed when comparing Temperature objects </summary>
        </member>
        <member name="P:UnitClassLibrary.TemperatureDeviationDefaults.AcceptedEqualityDeviationDistance">
            <summary> When comparing two temperature and deviation is allowed to be within a specific constant. This is that default constant </summary>
        </member>
        <member name="P:UnitClassLibrary.TemperatureDeviationDefaults.TemperatureAcceptedEqualityDeviationDistancePercentage">
            <summary> When comparing two temperature and deviation is allowed to be within a percentage of the firstTemperature. This is that percentage </summary>
        </member>
        <member name="T:UnitClassLibrary.TemperatureEqualityStrategyImplementations">
            <summary> functions that can be used for a temperature object's equals functions </summary>
        </member>
        <member name="M:UnitClassLibrary.TemperatureEqualityStrategyImplementations.DefaultPercentageEquality(UnitClassLibrary.Temperature,UnitClassLibrary.Temperature)">
            <summary> Temperatures are equal if they differ by less than a percentage of the first Temperature </summary>
            <param name="temperature1">first temperature being compared</param>
            <param name="temperature2">second temperature being compared</param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.TemperatureEqualityStrategyImplementations.DefaultConstantEquality(UnitClassLibrary.Temperature,UnitClassLibrary.Temperature)">
            <summary> Temperatures are equal if there values are within the passed deviation constant. If they are not within the constant </summary>
            <param name="temperature1">first temperature being compared</param>
            <param name="temperature2">second temperature being compared</param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Time.#ctor(UnitClassLibrary.TimeEqualityStrategy)">
            <summary> Zero Constructor </summary>
        </member>
        <member name="M:UnitClassLibrary.Time.#ctor(UnitClassLibrary.TimeType,System.Double,UnitClassLibrary.TimeEqualityStrategy)">
            <summary> Accepts standard types for input. </summary>
        </member>
        <member name="M:UnitClassLibrary.Time.#ctor(UnitClassLibrary.Time)">
            <summary> Copy constructor (new unit with same fields as the passed) </summary>
        </member>
        <member name="M:UnitClassLibrary.Time.ConvertTime(UnitClassLibrary.TimeType,System.Double,UnitClassLibrary.TimeType)">
            <summary>
            Converts from one TimeType to another
            </summary>
            <param name="typeConvertingFrom"></param>
            <param name="passedValue"></param>
            <param name="typeConvertingTo"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Time.EqualsWithinDeviationConstant(UnitClassLibrary.Time,UnitClassLibrary.Time)">
            <summary> value comparison, checks whether the two are equal within a passed accepted equality deviation </summary>
        </member>
        <member name="M:UnitClassLibrary.Time.EqualsWithinDeviationPercentage(UnitClassLibrary.Time,UnitClassLibrary.Time)">
            <summary> value comparison, checks whether the two are equal within a passed accepted equality percentage </summary>
        </member>
        <member name="M:UnitClassLibrary.Time.EqualsWithinDistanceEqualityStrategy(UnitClassLibrary.Time,UnitClassLibrary.TimeEqualityStrategy)">
            <summary> value comparison, checks whether the two are equal within a passed accepted equality percentage </summary>
        </member>
        <member name="M:UnitClassLibrary.Time.CompareTo(UnitClassLibrary.Time)">
            <summary> This implements the IComparable (Time) interface and allows Times to be sorted and such </summary>
        </member>
        <member name="M:UnitClassLibrary.Time.CompareTo(System.Object)">
            <summary> This implements the IComparable (Time) interface and allows Times to be sorted and such </summary>
        </member>
        <member name="M:UnitClassLibrary.Time.op_ExclusiveOr(UnitClassLibrary.Time,System.Double)">
            <summary>Raise to power operator</summary>
            <param name="o1"></param>
            <param name="power"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Time.op_Addition(UnitClassLibrary.Time,UnitClassLibrary.Time)">
            <summary>Returns new unit with sum of two passed units</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Time.op_Subtraction(UnitClassLibrary.Time,UnitClassLibrary.Time)">
            <summary>Returns new unit with difference of two passed units</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Time.op_Division(UnitClassLibrary.Time,UnitClassLibrary.Time)">
            <summary>ratio between differences</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Time.op_Multiply(UnitClassLibrary.Time,System.Double)">
            <summary>scalar multiplication</summary>
            <param name="o1"></param>
            <param name="multiplier"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Time.op_Multiply(System.Double,UnitClassLibrary.Time)">
            <summary>scalar multiplication</summary>
            <param name="o1"></param>
            <param name="multiplier"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Time.op_Division(UnitClassLibrary.Time,System.Double)">
            <summary>scalar division</summary>
            <param name="o1"></param>
            <param name="divisor"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Time.op_Inequality(UnitClassLibrary.Time,UnitClassLibrary.Time)">
            <summary>Not a perfect inequality operator, is only accurate up to Constants.AcceptedEqualityDeviationConstant </summary>
        </member>
        <member name="M:UnitClassLibrary.Time.op_Equality(UnitClassLibrary.Time,UnitClassLibrary.Time)">
            <summary>Not a perfect equality operator, is only accurate up to Constants.AcceptedEqualityDeviationConstant </summary>
        </member>
        <member name="M:UnitClassLibrary.Time.op_GreaterThan(UnitClassLibrary.Time,UnitClassLibrary.Time)">
            <summary>greater than</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Time.op_LessThan(UnitClassLibrary.Time,UnitClassLibrary.Time)">
            <summary>less than</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Time.op_LessThanOrEqual(UnitClassLibrary.Time,UnitClassLibrary.Time)">
            <summary>less than or equal to</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Time.op_GreaterThanOrEqual(UnitClassLibrary.Time,UnitClassLibrary.Time)">
            <summary>greater than or equal to</summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Time.GetHashCode">
            <summary>This override determines how this object is inserted into hashtables.</summary>
            <returns>same hashcode as any double would</returns>
        </member>
        <member name="M:UnitClassLibrary.Time.ToString">
            <summary>The value and unit in terms of what the object was created with. </summary>
            <returns>Should never return anything</returns>
        </member>
        <member name="M:UnitClassLibrary.Time.Equals(System.Object)">
            <summary>calls the Dimension only Equals method</summary>
        </member>
        <member name="M:UnitClassLibrary.Time.Equals(UnitClassLibrary.Time)">
            <summary>Compares using the function specified by strategy</summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Time.ToString(UnitClassLibrary.TimeType)">
            <summary>prints the value and unit type converted to</summary>
            <param name="timeType"></param>
        </member>
        <member name="M:UnitClassLibrary.Time.Negate">
            <summary>Creates a new object that is the negative of this</summary><returns>new object with value equivalent to result</returns>
        </member>
        <member name="M:UnitClassLibrary.Time.AbsoluteValue">
            <summary>Creates a new object that is the absolute value of this</summary><returns>new object with value equivalent to result</returns>
        </member>
        <member name="M:UnitClassLibrary.Time.RaiseToPower(System.Double)">
            <summary> multiplies itself a given number of times</summary><returns>new object with value equivalent to result</returns>
        </member>
        <member name="M:UnitClassLibrary.Time.MakeTimeWithNanoseconds(System.Double)">
            <summary>Generator method that constructs Time with assumption that the passed value is in Nanoseconds</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Time.MakeTimeWithMicroseconds(System.Double)">
            <summary>Generator method that constructs Time with assumption that the passed value is in Microseconds</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Time.MakeTimeWithMilliseconds(System.Double)">
            <summary>Generator method that constructs Time with assumption that the passed value is in Milliseconds</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Time.MakeTimeWithSeconds(System.Double)">
            <summary>Generator method that constructs Time with assumption that the passed value is in Seconds</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Time.MakeTimeWithMinutes(System.Double)">
            <summary>Generator method that constructs Time with assumption that the passed value is in Minutes</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Time.MakeTimeWithHours(System.Double)">
            <summary>Generator method that constructs Time with assumption that the passed value is in Hours</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Time.MakeTimeWithDays(System.Double)">
            <summary>Generator method that constructs Time with assumption that the passed value is in Days</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Time.MakeTimeWithWeeks(System.Double)">
            <summary>Generator method that constructs Time with assumption that the passed value is in Weeks</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Time.MakeTimeWithMonths(System.Double)">
            <summary>Generator method that constructs Time with assumption that the passed value is in Months</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Time.MakeTimeWithYears(System.Double)">
            <summary>Generator method that constructs Time with assumption that the passed value is in Years</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Time.MakeTimeWithDecades(System.Double)">
            <summary>Generator method that constructs Time with assumption that the passed value is in Decades</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Time.MakeTimeWithCenturies(System.Double)">
            <summary>Generator method that constructs Time with assumption that the passed value is in Centuries</summary>
            <param name="passedValue"></param>
            <returns></returns>
        </member>
        <member name="T:UnitClassLibrary.TimeType">
            <summary> Enum for specifying the type of unit a Time is.</summary>
        </member>
        <member name="T:UnitClassLibrary.TimeEqualityStrategy">
            <summary>delegate that defines the form of</summary>
            <param name="time1"></param>
            <param name="time2"></param>
            <returns></returns>
        </member>
        <member name="T:UnitClassLibrary.TimeDeviationDefaults">
            <summary> Default deviations allowed when comparing Time objects </summary>
        </member>
        <member name="P:UnitClassLibrary.TimeDeviationDefaults.AcceptedEqualityDeviationDistance">
            <summary> When comparing two time and deviation is allowed to be within a specific constant. This is that default constant </summary>
        </member>
        <member name="P:UnitClassLibrary.TimeDeviationDefaults.TimeAcceptedEqualityDeviationDistancePercentage">
            <summary> When comparing two time and deviation is allowed to be within a percentage of the firstTime. This is that percentage </summary>
        </member>
        <member name="T:UnitClassLibrary.TimeEqualityStrategyImplementations">
            <summary> functions that can be used for a time object's equals functions </summary>
        </member>
        <member name="M:UnitClassLibrary.TimeEqualityStrategyImplementations.DefaultPercentageEquality(UnitClassLibrary.Time,UnitClassLibrary.Time)">
            <summary> Times are equal if they differ by less than a percentage of the first Time </summary>
            <param name="time1">first time being compared</param>
            <param name="time2">second time being compared</param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.TimeEqualityStrategyImplementations.DefaultConstantEquality(UnitClassLibrary.Time,UnitClassLibrary.Time)">
            <summary> Times are equal if there values are within the passed deviation constant. If they are not within the constant </summary>
            <param name="time1">first time being compared</param>
            <param name="time2">second time being compared</param>
            <returns></returns>
        </member>
        <member name="T:UnitClassLibrary.Volume">
             <summary>
            Distance class for volume
             </summary>
        </member>
        <member name="M:UnitClassLibrary.Volume.#ctor">
            <summary>
            Default Constructor
            </summary>		
        </member>
        <member name="M:UnitClassLibrary.Volume.#ctor(UnitClassLibrary.Volume)">
            <summary>
            copy constructor - create a new Volume with the same _intrinsicValue as the passed Volume
            </summary>
        </member>
        <member name="M:UnitClassLibrary.Volume.#ctor(UnitClassLibrary.VolumeType,System.Double)">
            <summary>
            sets the volume to the passed double with the passed unit type
            </summary>
            <param name="volumeType">passed unit type</param>
            <param name="passedValue">volume of unit type</param>		
        </member>
        <member name="M:UnitClassLibrary.Volume.storeAsInternalUnit(UnitClassLibrary.VolumeType,System.Double)">
            <summary>
            Stores the value argument according to the type argument.
            </summary>
            <param name="passedType">unit type</param>
            <param name="passedValue">value to set area to</param>
        </member>
        <member name="M:UnitClassLibrary.Volume.retrieveAsExternalUnit(UnitClassLibrary.VolumeType)">
            <summary>
            Uses VolumeConverter to convert to the volume requested from intrinsic Milliliters
            </summary>
            <returns>volume in specified unit type</returns>
        </member>
        <member name="M:UnitClassLibrary.Volume.ConvertVolume(UnitClassLibrary.VolumeType,System.Double,UnitClassLibrary.VolumeType)">
            <summary>
            universal converter to and from volume types
            </summary>
            <param name="typeConvertingFrom">unit type to convert from</param>
            <param name="passedValue">value to convert</param>
            <param name="typeConvertingTo">unit type to convert to</param>
            <returns>double of volume in typeConvertingTo</returns>
        </member>
        <member name="M:UnitClassLibrary.Volume.op_Addition(UnitClassLibrary.Volume,UnitClassLibrary.Volume)">
            <summary>
            adds two volumes together
            </summary>
            <returns>sum of two volumes</returns>
        </member>
        <member name="M:UnitClassLibrary.Volume.op_Subtraction(UnitClassLibrary.Volume,UnitClassLibrary.Volume)">
            <summary>
            subtracts a volume from the other
            </summary>
            <returns>v1 - v2</returns>
        </member>
        <member name="M:UnitClassLibrary.Volume.op_Equality(UnitClassLibrary.Volume,UnitClassLibrary.Volume)">
            <summary>
            checks equality of two volumes
            </summary>
            <returns>true if the volumes are equal</returns>
        </member>
        <member name="M:UnitClassLibrary.Volume.op_Inequality(UnitClassLibrary.Volume,UnitClassLibrary.Volume)">
            <summary>
            checks inequality of two volumes
            </summary>
            <returns>true if the volumes are not equal</returns>
        </member>
        <member name="M:UnitClassLibrary.Volume.op_GreaterThan(UnitClassLibrary.Volume,UnitClassLibrary.Volume)">
            <summary>
            checks specific inequality of two volumes
            </summary>
            <returns>whether the first volume is larger than second volume</returns>
        </member>
        <member name="M:UnitClassLibrary.Volume.op_LessThan(UnitClassLibrary.Volume,UnitClassLibrary.Volume)">
            <summary>
            checks specific inequality of two volumes
            </summary>
            <returns>whether the first volume is smaller than second volume</returns>
        </member>
        <member name="M:UnitClassLibrary.Volume.op_GreaterThanOrEqual(UnitClassLibrary.Volume,UnitClassLibrary.Volume)">
            <summary>
            checks if volume 1 is greater than or equal to volume 2
            </summary>
            <returns>whether the first volume is smaller than second volume</returns>
        </member>
        <member name="M:UnitClassLibrary.Volume.op_LessThanOrEqual(UnitClassLibrary.Volume,UnitClassLibrary.Volume)">
            <summary>
            less than or equal to
            </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <returns></returns>
        </member>
        <member name="M:UnitClassLibrary.Volume.GetHashCode">
            <summary>
            This override determines how this object is inserted into hashtables.
            </summary>
            <returns>same hashcode as any double would</returns>
        </member>
        <member name="M:UnitClassLibrary.Volume.ToString">
            <summary>
            The value and unit in terms of what the object was created with. 
            If you want it in a different unit use ToString(VolumeType)
            </summary>
            <returns>Should never return anything</returns>
        </member>
        <member name="M:UnitClassLibrary.Volume.Equals(System.Object)">
            <summary>
            value comparison, checks whether the two are equal within the accepted equality deviation specified in Constants
            </summary>
        </member>
        <member name="M:UnitClassLibrary.Volume.EqualsWithinPassedAcceptedDeviation(System.Object,UnitClassLibrary.Volume)">
            <summary>
            value comparison, checks whether the two are equal within a passed accepted equality deviation
            </summary>
        </member>
        <member name="M:UnitClassLibrary.Volume.CompareTo(UnitClassLibrary.Volume)">
            <summary>
            This implements the IComparable interface and allows Volumes to be sorted and such
            </summary>
            <param name="other">volume to check against</param>
            <returns>0 if equal; 1 if this greater than other; -1 if this less than other </returns>
        </member>
        <member name="P:UnitClassLibrary.Volume.Milliliters">
            <summary>
            uses Milliliters as a property and retrieves as an external unit when necessary
            </summary>		
        </member>
        <member name="P:UnitClassLibrary.Volume.CubicCentimeters">
            <summary>
            uses CubicCentimeters as a property and retrieves as an external unit when necessary
            </summary>		
        </member>
        <member name="P:UnitClassLibrary.Volume.Liters">
            <summary>
            uses Liters as a property and retrieves as an external unit when necessary
            </summary>			
        </member>
        <member name="P:UnitClassLibrary.Volume.CubicMeters">
            <summary>
            uses CubicMeters as a property and retrieves as an external unit when necessary
            </summary>			
        </member>
        <member name="P:UnitClassLibrary.Volume.CubicThirtySeconds">
            <summary>
            uses CubicThirtySeconds as a property and retrieves as an external unit when necessary
            </summary>			
        </member>
        <member name="P:UnitClassLibrary.Volume.CubicSixteenths">
            <summary>
            uses CubicSixteenths as a property and retrieves as an external unit when necessary
            </summary>			
        </member>
        <member name="P:UnitClassLibrary.Volume.CubicInches">
            <summary>
            uses CubicInches as a property and retrieves as an external unit when necessary
            </summary>			
        </member>
        <member name="P:UnitClassLibrary.Volume.CubicFeet">
            <summary>
            uses CubicFeet as a property and retrieves as an external unit when necessary
            </summary>			
        </member>
        <member name="P:UnitClassLibrary.Volume.CubicYards">
            <summary>
            uses CubicYards as a property and retrieves as an external unit when necessary
            </summary>			
        </member>
        <member name="P:UnitClassLibrary.Volume.CubicMiles">
            <summary>
            uses CubicMiles as a property and retrieves as an external unit when necessary
            </summary>			
        </member>
        <member name="P:UnitClassLibrary.Volume.Gallons">
            <summary>
            uses Gallons as a property and retrieves as an external unit when necessary
            </summary>			
        </member>
        <member name="P:UnitClassLibrary.Volume.Quarts">
            <summary>
            uses Quarts as a property and retrieves as an external unit when necessary
            </summary>			
        </member>
        <member name="P:UnitClassLibrary.Volume.Pints">
            <summary>
            uses Pints as a property and retrieves as an external unit when necessary
            </summary>			
        </member>
        <member name="P:UnitClassLibrary.Volume.Cups">
            <summary>
            uses Cups as a property and retrieves as an external unit when necessary
            </summary>			
        </member>
        <member name="P:UnitClassLibrary.Volume.FluidOunces">
            <summary>
            uses FluidOunces as a property and retrieves as an external unit when necessary
            </summary>			
        </member>
    </members>
</doc>
